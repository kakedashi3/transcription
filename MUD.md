https://youtu.be/UvIWmzscWp8

Chunk 0 transcription: 

Welcome to MUD. My name is Alvarius and today we're going to build an on-chain app to demonstrate how to get started with the framework, build something real and then deploy to production. But before we jump into the code, let me give you a very brief overview of a couple of important concepts in MUD so that everything else clicks into place much faster. Let's start with a quick reminder of how on-chain development used to work without MUD. So in the old world, let's say we want to create a contract where we want to store a mapping of the owners of a given address. We store a mapping, we call it owned by from address to address and then we create a function set owner which allows us to set the owner of a given address. That function emits an event and then we set the owner in our owned by mapping. The data is going to be stored in storage and the location of the data in storage depends on the hash of the key that we use to index the mapping. That means if we have access to a full node, we can read all the values in storage but we can never recover the key because the key was hashed to find the storage location. And if we want other contracts to be able to get the owner of a given address, we have to remember to implement a custom getter function because without this function, another contract really has no way of accessing this value in the storage. In our frontends, we most likely also want to know which addresses have an owner. So what are all the keys that have been set in this mapping? And this is why we had to remember to emit our custom event in our set function, set owner, which also includes the key so that a custom indexer can now index this event and then our clients can ask the indexer to get a list of all the keys that have been set in this mapping. Doing all of this for every state variable we need in our contracts is very cumbersome and this is why we created MUDstore. With MUDstore, you don't need any custom getter functions, you don't need any custom events, you don't need any custom indexers and you don't need any custom networking code because all of this comes by default. So how does this work? We start with a standard data model that is based on tables and then we provide an optimized call library that is used to interact with the standard data model, with these tables. And because the user doesn't interact with storage directly but rather through this library, the library can take care of optimizing the storage layout and so in some cases even can achieve more efficient data packing than native solidity. And then this call library also emits events by default for every state change, which then can be picked up by a default indexer which can be used by clients to get the state very quickly. The standard data model is very simple. All the data is stored in tables and every table has a schema that describes the types of values that are stored in this table and then every record that means a row in the table has a key which is used to index this row in the table. Here is an example of an owner table that has a schema with a single field called owner and the value that is stored in this field is an address. And then each row is indexed by a bytes 32 key which is implicit in the schema because we didn't provide any override for a key schema. Here's an example of another table called the position table and this table has a schema with two fields, one x and one y, and both of them have type int32 and again we didn't provide a key schema so we're using an implicit bytes 32 as a key. And lastly here is an example for a balance table. This time we do provide a key schema which means the key has two pieces. The first one is owner and is of type address. The second one is item and is of type uint32 and then our value schema has a single field called amount and is of type uint256 and this means every row in this table is indexed by the tuple of owner and item and then the value of this row is the amount. The data in these tables is modified through the optimized call library but you as a developer never have to actually touch this call library directly but rather we generate typed wrapper libraries for you based on the table schema. And another thing that you as a developer never have to worry about is emitting events for when data changes because the call library does it automatically and then based on these events the default indexes can index the data and make it available in an SQL database to any client. So as a quick recap, MUDstore gives you structured schemas, storage optimization, tight encoding and default indexers and it's compatible with any contract as a plug-in replacement for a native solidity storage. The second piece of the MUD protocol that I quickly want to give you an intro about is the MUD world which gives you permissionlessly extendable contracts. And here's how it works. At first a single world contract is deployed. Inside of this world contract

Chunk 1 transcription: 

anyone can register a new namespace. And then inside of the namespace, the owner of the namespace can register new tables that contain the data of this namespace. This is powered by MudStore, and this is a major difference to Vanilla Solidity. Because in Vanilla Solidity, you would define the data types at the time when you write your contract, and then you deploy that contract and the data types are fixed. Here we're registering a new table inside of an existing contract at runtime. To extend the functionality of the world, the owner of a namespace can register new systems in their namespace. And for each system, a function selector is gonna be registered in the world contract so that the system can be called through the world contract. By default, systems can read data from all the tables, but they can only write to tables in their own namespace. And they can write to tables where the owner of the namespace gave explicit approval to the system to write to this table. MudStore and MudWorld are two important lower level pieces of the Mud protocol. But now we're gonna focus on the Mud framework, which is the thing that glues all of this together into an engine for ambitious on-chain applications. And it comes with batteries included, it comes with a CLI, it comes with a development server and dashboard, and it comes with templates. And this is what we're gonna have a look at now. So let's create a new Mud project. We can do so by running pnpm create mud at canary. And then we put the name of our project that we wanna set up. In this case, it's Mud 101. And we put at canary because we wanna use the latest alpha version of Mud. So now we're asked to choose between the React version and the vanilla version of the template. And for the sake of this video, I'm gonna choose the React version here. So now I'm just gonna download all the packages, install all the dependencies, and gonna set up our product. And once that's done, we can CD into our project and run pnpm run dev to start the local development server. What this is doing is setting up a local Ethereum node, deploying all the contracts to that local Ethereum node, and also starting a local web development server. All right, so this is done. It's saying Mud watching for changes because later when we change our files, it's gonna automatically redeploy and recompile everything. But for now, let's just head over to the browser and have a look at our app. We can go to localhost 3000, which is where the local web server is running to have a look at the app that was just created for us. Here on the right side, we can see the Mud dev tools. On the very top, you see a couple of general stats about the current chain that we're running on, in this case, our local founder chain. We can see that the block number is increasing because we're connected to our local RPC node. And we can also see a burner wallet that was created for us when we loaded this page for the first time. We see our balance, which is zero ETH, which is fine because we're on a local development chain. And then we can see a couple of store events that were emitted when we set up the app for the first time. And then on the left side, we see the app that was just created for us. If we press the button here, we see there's a new action coming through and we see one new store event at the bottom, the counter value, which got increased to two. What's happening here in the background is that if we press the button, a transaction is sent to the chain and then Mud synchronizes the state of the chain in the background automatically to the UI and to the client. And to show you how that works, let's jump into the code. Our project is split up into two packages. We have one client package and we have one contract package. And the first thing we're gonna have a look at is the Mud config, which we find inside of the contract package under mud.config.ts. And in here, we see that we currently have a single table set up, the counter table. And we see that this table has a schema with a single field, which is a UN32. And then we also see a key schema that has no keys inside of it. And the reason for this is that our counter table has only a single row. We call this a singleton table and we don't need any keys for it because it only has a single row. Now, this is our config. And based on this config, Mud code generated a library to interact with this table. And we can find this library in code gen tables and then counter.sol. And here we see, okay, this is a code generated, an auto generated file. We should not edit this manually. And we see a bunch of methods that were generated for us, but we don't have to look at this in detail. We can just look at it in the code. And we can see that we have a single table with a single row. And we can also see that we have a single table

Chunk 2 transcription: 

close this again and interact with it as a black box. Now the next thing we're going to have a look at is the client. For this we switch to the client package and we go into source and open app.tsx which includes the source code of the page we just saw. Here we see the counter with the counter value behind it and we see the increment button that we just saw on the page that we opened. And we also see that when we press this increment button the increment function is called which comes from system calls. So let's look at where this comes from. This is coming from create system calls which is a function inside of source, mut and then create system calls.ts and in here we set up our functions that we want to call in the world contract. So what actually happens here is we call a function on the world contract by a world send and the function that we're calling is the increment function and we don't provide any arguments here. So let's switch back to the contract package to see where this function is coming from. I'm closing the clients package, going back to contracts and then I'm going inside of source and I'm opening the systems folder and I see a single system, the increment system. Every contract whose name ends in system is automatically considered a system by mut and it's going to be registered in the world contract during the deploy process of mut. And then for every function selector inside of that system this function selector is also going to be registered on the world contract so that people can call this function directly through the world contract. And then the world contract forwards the call to our system contract. So in this case we have a single increment function and this function is registered on the world contract which is why we were able to call the increment function directly on the world contract from the client. Now what this function does is it reads the current value from the counter table and remember this is a singleton cable so we don't have to provide a key and then it increases that value by one and it sets the new value on the counter table again. So if we go back to our app we can now read the value from the counter table through this hook called use component value and then this is the value that we display in the app. Now the reason why this is called use component value is because this is coming from a pattern called ECS or entity component systems. For the sake of this tutorial we're not going to go into ECS though and so I'm gonna quickly replace this with a lower level hook called use row which also allows us to read rows from a table and doesn't have the ECS abstraction around it. To use this hook I have to provide the store cache which is where MUT synchronizes all the contracts they do and I can get this from the network here and then I provide that as the first argument and the second argument is going to include the table that we want to filter for which in this case is the counter table and then we also have to provide an argument for the key that we're interested in but in this case since it's a singleton cable the key can be empty and because our return value is slightly different we have to fix this up here and provide the key of the value which in our case is also called value and then just to confirm everything still works I'm going back to the browser pressing the increment button I see the transaction going through and I see the state being synchronized and updated in the UI. We don't need these imports anymore so let me just real quick clean this up removing this import removing the components and we also don't need the singleton entity anymore. Alright now let's create a new feature. I want to create a balance table which stores the balance of a certain item that a certain address has and I want to create a mint system which allows people to mint a certain amount of a certain item. So the first thing that we're going to do is go back to our mudconfig and add the configuration for that new table. We're going to call this table the balance table and we're going to give it a schema of a single UN32. And this time we want to have multiple rows in our table and we want each row to be indexable by a composite key of the owner which is an address and the type of item which is going to be a UN32 as well. Once we save this file the MUD development server is going to pick up the change to our config and then auto generate the new table.

Chunk 3 transcription: 

the new table that we just defined here which we can find in CodeGen and then in tables we see there's a new auto-generated table library called BalanceTable. All right so let's create a new system to interact with this new table. For this we go into systems and we create a new file that we call the min system and I'm just going to copy the code from the increment system for now and I'm going to paste it into a new file and then I'm going to clean up everything that we don't need. So we're going to rename this to min system and I'm going to remove everything that is in here and we don't want to interact with the counter table but rather the balance table. So I'm going to put balance here and of course I named this table not just balance but balance table and this is why I have to import from balance table here. Next we're going to create our mint function which we just call mint and we take one argument as an input which is going to be our item that we want to mint and this is a public function and then we want to grab the current balance of the caller of this function to be able to increase it and for this we're going to do balance table dot get and now we have to provide the two keys that we use to index each row in this table and so the first index the first key is going to be the address of the caller and the second index is going to be the item and one thing to note here is that we don't use message dot sender here but rather we use underscore message sender which is a function that's implemented on the system base contract and the reason for this is that this system contract is not called directly but rather it's called through the world contract and so the world contract is forwarding the original caller of the system through this function and now that we have the balance we want to increase the balance and set the increased balance on the balance table so I want to set the balance of the message sender of the current item with the new balance plus five and that's all we need to do for now. Now once I save this file the MUT development server is going to pick up the change recompile all the contracts and redeploy the world with the new contracts but we don't have any way to interact with it yet from the front end and so we quickly set up a connection to the front end by going back into our client and into source into MUT and into create system calls and in here we're just going to create a little wrapper function to call our contract this is really just for our convenience to not have to call the contract directly in app.tsx but we call this function mint and in here all we have to do is call world send with the new mint function which is now available on world send because everything was recompiled in the background and it tells us we need one more argument the item so we're going to provide an item here and we're just going to put one for now and then we return this function to make it available on the context that we use in app.tsx. Now let's go back to app.tsx and let's clean up all the things that we don't need anymore in here so we don't need the counter anymore we don't need this div anymore and we also don't need the button anymore and instead I'm going to create a new button which will be our mint button and on click of this button we are going to call the mint function which we can get from the system calls object up here and then we want to call this when we click the mint button all right this is all we need now let's go back to our browser and we see the mint button and we see that if we click this mint button a mint transaction is sent to the contracts and it's confirmed and then here in the recent store events we can see a new event that came in which is an event an update to the balance table where we see it now has value 5 for some key but the new value but the new value is not displayed in the UI yet because we didn't set up that connection yet so let's go back to our code and let's set up a connection in the UI so I want to get all the balances from our balance table so in this case I'm going to use a different hook I'm going to use the use rows hook and it behaves very similar to the use row hook we also provide the store cache as the first argument and then as the second argument I provide a filter object which will include the table itself so that eventually it's going to be a to tell the person a intrance

Chunk 4 transcription: 

that I want to filter on, which in this case is the balance table. And then we're going to set up a very simple UI for this by looping over every element of the balances array, every row in the balance table, and we map each of these rows to a paragraph element so that we can see it in our browser. And here we just put balance.key.owner has and then we want to have the number of items it has, so balances.value.value this is because the the only value in our schema is called value right now and now the type of item, this is part of the key, so we do balance.key.owner has a key.item and then we can save this and head back to our browser and see the result. Well, you can confirm that this is my address by looking at my address in the MUD dev tools, but this is way too long so I'm just quickly going to shorten this to 10 characters and then when we go back to our browser this is much more readable and you can see my address has five items of type one and if we press the min button again you see the UI is updating, you see the transaction on the right and you see the event in the dev tools. Alright, now the last thing that's missing is deploying this to an actual chain, so let's stop our development server here and let's clean this real quick and then let's go into the contracts directory from where we're going to deploy our contracts to an actual chain. The first thing we have to do here is create a new wallet, so I'm just going to use the cast utility to create a new random wallet and I'm going to copy my private key and I'm going to head back over to the code into the contracts package where I can find a .end file which includes the environment variables and I'm going to paste my private key there. So far it has included the default envl private key and I'm going to override it with the newly created private key from cast. Then I head back to the console and I copy the address and because this is a fresh private key and fresh address it's not going to have any funds on the testnet and so because we want to deploy to the lattice testnet I can just say pnpm mudfaucet dash dash address and then I paste the address here and the mudfaucet is gonna drip me some ETH to this new address so that we can deploy to the testnet. And now the last thing that I have to do to deploy to the testnet is type pnpm deploy testnet which refers to a script that you can find in the package.json in the contracts package and now this is running the mud deployer again but this time we're deploying to an actual chain so this time it's going to take slightly longer than the the def runner which just deploys to the local chain because now we have to wait for every transaction to be actually confirmed by the real chain. And there we go the contracts have been deployed to the chain and we see the world address that it got deployed to and now to interact with this production deployment we're gonna start our development server again but just to have the development client running because we don't have our client deployed yet. So I'm going back to the project root running pnpm dev to start the development server again and it's starting both the development client as well as the development contracts but in this case we just care about the development client. The error that you see here is the contracts complaining that we're trying to deploy to the local development chain with a private key that doesn't have any funds on the local test chain but again this doesn't matter because we're only interested in the client here. And if we scroll up a little we can see that the client is running fine. So this is all we care about so we can go back to our browser and to connect to the production chain we just have to append the chain ID param to the URL so we type question mark chain ID equals 4242 which is the chain ID of the lattice testnet that we just deployed to and we press enter and now you see it's connected to the lattice testnet. You see the block number increasing because it's connected to the testnet RPC and you see our new burner wallet that was created for us here and we see the balance that we have on this testnet which is quite a bunch and if we press the mint button you can see the transaction being executed and being confirmed and you can see the balance value being updated and the I beingfilled.

Chunk 5 transcription: 

updated as well. This is a very simple app of course but it should give you an idea of how to get started with the framework and how to build something much more complex than this. If you want to dive deeper you can find the documentation at mud.dev and we're going to follow up with a bunch of videos that go deeper into specific topics like ECS and building games with MUD.
