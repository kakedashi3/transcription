https://youtu.be/ppYLt2GTeKA

Chunk 0 transcription: Good morning, everyone. Welcome to this workshop where we'll learn today about Unlock Protocol. This is a workshop that is dedicated to developers or people at hackathons that want to build on top of the Unlock Protocol. Here's to get started a quick agenda about what Unlock is. First we'll start with an overview, then we'll look at the ecosystem, what kind of tools, including the subgraphs from the graph and what kind of integrations exist out there. Then we'll move into a final section about two different tutorials. One of them is to show you use cases for frontend and how to create one, as well as use cases for smart contract integration, as well as creating a hook, which is something that is very specific to the Unlock smart contracts. First of all, a little bit about myself. My name is Julien Genestoux. I'm the CEO and founder here at Unlock Protocol. Before that, I was actually working in a company called Superfeeder, which was sold to Medium in 2016. Superfeeder was building RSS feed API, RSS, our core building block of the open web. And we have to think of Unlock as another building block for the open web. I'm a big open source advocate. I'm a W3C invited expert, and I'm also a member of the graph council. You can find me online at julien51, mostly everywhere, or use my site at ouvreboite.com, O-U-V-R-E dash B-O-I-T dot com. So let's jump right into it. What is Unlock Protocol? Unlock Protocol is a protocol for memberships. What does that mean? You might ask. Well, simply thought, Unlock Protocol is a system to create membership and sell access NFTs, membership NFTs in minutes. It allows developers like yourself to create memberships, subscription, a ticketing solution, and token getting to websites, create certifications and gaming. And we'll come back to all of these. It is obviously completely open source under the MIT license. It is community governed, which means that we have a DAO and a governance token. And if you're building on top of Unlock, we invite you to join our DAO so you can help us make decisions about the future of the protocol. There is a set of application that we have built at Unlock Labs, but also other people have built similarly with libraries and developer tools. It was founded by me in 2018. And we now have a team with diverse experience from Google, Facebook, GoDaddy, and multiple others as well as a global community of people around the world. So let's talk more about memberships and NFT specifically. So can I use any NFT to represent membership? And especially here, you might recognize some of the popular projects out there. The short answer is no, you should not. I mean, you can, but you should not. And the reason why you should not is because these default NFTs, specifically the collectible NFTs, are limited in what they allow you to do. For example, the number one limitation is that they're valid forever. They're perpetual. And when you create a membership of any kind, you actually probably want to have it time bound. Think of your Netflix membership or your Amazon Prime membership. It is time bound. It is valid for a month and it renews for another month and for another month and for another month for as long as you pay, but it is not valid forever. Similarly, think about a certification. Your driver license in the US, for example, is a membership to the DMV and it is limited in time. It's valid for five years and then you have to renew it to prove that you still know how to drive. So using regular NFTs would not work really well for this. This time aspect, as we just alluded to, also allows you, developer, to build in recurring revenue, mechanisms for your application or for your community to have sustainable funding every week, every month, every year, depending on what is the timeline that you choose, because the NFTs expire over and over again. It allows you to move from the concept of royalties, which is very linked to the NFT contract, to more continuous revenue, where again, as your community is accruing revenue on a constant basis. Similarly, at Unlock, we've built inside the smart contract several capabilities that would allow you to support not just crypto payments, but also payment using, for example, EFC20 tokens. And specifically on top of that, also fiat payments using credit cards, for example, and we'll come back to this in the future as well. It also allows for off-chain access verification, as well as on-chain access control. Each of these NFTs can be signed to prove their authenticity. And then from the signature, we can generate, for example, QR code that are shown on tickets as a way to prove that somebody might have or should have access to a venue, for example, if they are attending a concert or conference. Similarly, some memberships are transferable.
Chunk 1 transcription: But others, and I'd say almost the majority of them, should not be transferable. Your Netflix account is probably not transferable, even if you share your password with your friends. A certification, a diploma, is definitely not transferable. You don't want to be able to transfer your diploma from an organization to another. But you can also imagine that some social clubs, for example, have memberships that are transferable. If you're not currently part of the club, you can transfer that to someone else that'd be able to join the club, and then you're not able to join anymore. Obviously, the contract that we've built at Unlock are ESC 721, which is the same default NFT contract that you've used in most places. But it has been built with a ton of characteristics. When you think about collectible, it's important, maybe even critical, that the contract itself is immutable, that whatever is in the contract on the first day is there forever. But when you're thinking about membership as a more generic concept, it might actually be interesting to be able to upgrade or change how the contract behaves. For example, the price of the membership might increase, and that is something that is supported natively by Unlock as well. Specifically, Unlock's contracts are updatable. You can change the name of the contract, the price of the membership, the duration of the membership, the supply, the number of membership that there could be. You can also change a specific membership. You can imagine that in some cases, membership can be revoked. Even though somebody might have paid for this, you might allow them to cancel and get a refund, or they can be assigned to someone else. The contracts are also upgradable. We've built the contract with the idea that the protocol will evolve over time, and each contract should be upgradable, not by us, obviously, but by the person who deployed it. So a specific creator that has deployed a membership contract should be able to opt in to a new version of the protocol if one has been made available by the DAO. Finally, and this is really kind of an interesting aspect here, the protocol contracts, the public locks, as we call them, are programmable. They're programmable because we realized, like, as a developer, you might want to build custom logic into your membership contract. So we do that with a system of hooks that allow developers, and maybe even, at some point, creators, to add or change the behavior of the smart contract based on some characteristics. So for example, that's how we support discount codes on membership. You can say, you know, the membership price is $10, but if a user, as they go through checkout, as they purchase their membership, they enter a specific discount code, they should only be paying, you know, $5 or $8. And that is through the use of hooks, and we'll come back to this in the last section of this presentation. Let's talk about some key important use cases, because I alluded to a few, but let's be more specific. As I said, event ticketing. A ticket to a conference, a ticket to a concert, is a membership, a one-off membership, one that is, you know, just for that specific event, but it is a membership. You can also build some kind of recurring subscription. I mentioned Netflix, Amazon Prime. These are a good example of this. If you use Substack, or if you support some creators using Patreon, you're probably familiar with the idea of the recurring subscription, where the user pays, you know, on a monthly basis for a certain amount of money. They can also be time-based. So you can build, for example, seasons in your application. Say, okay, there's cohorts that are used for people to, for example, govern a specific project only for the duration of the project. And so basically, these are time-based membership. We mentioned certifications, credential, diplomas. All of these are membership. You're a member of the university or the alumni class of a specific year, and that's how you get your diploma. You're a member of the people that got trained around using Ethereum for a year, and you get that certification. And it's valid for a year. You can use it to prove that you have gone through the certification, but at the end of that year, it should be considered expired, because maybe your knowledge is not up to date anymore. It is also useful in the context of gaming. Think of, you know, games where you unlock a level. Well, this is a membership to that level. Again, a bit strange to think of this as membership, but it really is if you think at the core of what a membership is. You're, as a user, as a player, you're part of the group. You're a member of the group of people that get access to level two. You can also be a member of the group that have, you know, access to a specific game item, a sword or something like this. It's also valid in the context of loyalty programs. So think of it as, you know, your airline miles program. You have a card that's a membership card that show that you're loyal to the brand and that you should be treated as a loyal customer in that example. Unlock can also be used for attendance NFTs, the proof of completion, the fact that you went somewhere, or as a result, you're a member of the group.
Chunk 2 transcription: way to commemorate something on chain. And finally, you can also use the unlock contract for digital collectibles, like PFP collection that we've seen before, or even any kind of other NFTs, regular collectible NFTs. The time limit, the time limit aspect, the time bound aspect can actually be very useful there as well. And if you want, for example, to have dynamic NFTs that evolve over time, so you can imagine your PFP gets older, unless the user extends it or renews it in that example. Let's dig deeper with some more specific use cases. So for ticketing, based on how the protocol is deployed right now, 100% of the ticket revenue goes to the creator or the event organizer. It's not like a platform that would take a cut here. The organizer fully controls the ticket distribution. And if maybe if they want, fully controls potentially the secondary market. They can avoid transfer or they can require transfer to go through a specific clearinghouse for these to happen. They can also create, and I think maybe where smart contracts shine, interoperable experiences for attendees before, during, or after the event. Imagine if the ticketing for an event is an NFT. You can use it, for example, to connect to a Discord server before the event and join all of the other attendees. Or you can use it when you connect to a reservation website to book, for example, a hotel room and prove that you have a ticket to get a discount for this. So that's the kind of thing that you can do before the event. After the event, or maybe during the event, you can use this as a way to build a system where people can vote on what is the best session of the conference. And only people that have a valid NFT can actually vote using a tool like Snapshot. If you were to use a traditional ticketing system, it would be really hard to build. You would have to build authentication to your application that plugs into the event ticketing application. And they probably don't have an API for this. And even if they do, they can restrict who can access that information. It's also useful after the event where you can imagine, for example, like next year's conference might have a discount for people that were here the previous year. If you have that concept of NFT as ticket, it's really easy to just program the smart contract to say whenever somebody has a ticket from last year, they should get a 10% discount. Tickets are membership cards that connect to a community of people that are interested in a specific concept. Unlock for ticketing has been used at multiple conferences in the crypto space, in the Ethereum space. And here we're showcasing Dapkon, which is a conference happening this year again in Berlin between September 11th and September 13th. Dapkon has used Unlock last year, actually. There's about a thousand attendees that are mostly in the crypto ecosystem. What's interesting here, they're using Unlock obviously, but they're also using Unlock on a specific chain. We haven't talked about this yet, but Unlock has been deployed on nine different EVM networks. So obviously you probably know of Ethereum Mainnet, you know of Polygon, but Dapkon chose Gnosis Chain, which I think is a very good option to deploy this smart contract. We're also on Optimism, on Arbitrum, and multiple others. You can find them all in our doc. What's interesting about Dapkon is that they're a crypto conference, and so it only makes sense that as a crypto conference, they're dogfooding. They're using the technology that they are writing or talking about. And in that example specifically, they decided to use Unlock for this. We also have built inside of the Unlock a reference ticketing application, a system to verify authenticity of tickets by scanning QR codes. So really excited about that use case. And if you want to build some kind of ticketing solution, you should try to inspire yourself from what Dapkon has done. Other examples of conferences that have used Unlock, ETH Taipei a couple of weeks ago in Taipei, ECC in Paris has used Unlock last year as well. ETH Warsaw is using Unlock for ticketing, etc. Another example of a use case that we talked about is the concept of subscriptions. So subscription enabled token access to expenses and services. Think again, a Netflix subscription, it gives you access, not token-based, but it gives you access to their streaming service to view applications. Your gym membership gives you physical access to the gym so you can exercise there. It is sustainable subscription and recurring revenue for the business that hosts it. They can use crypto or credit card for these things. And what's important here is like the business has a direct relationship with the members. There is no middleman involved in that situation. There is no service in between these two things. The Netflix example is an interesting one. You can get a Netflix subscription either from the Netflix.com website or through Apple or Google.
Chunk 3 transcription: on mobile devices. When that happens through mobile devices, as a matter of fact, Netflix and you know, Apple and Google act as middlemen here and they can change the terms. They can decide to not validate how the application works anymore. And this is not ideal for a business like Netflix, obviously. This is obviously useful for content. We talked about Substack briefly. For software, if you think about in-app purchases, a lot of these are subscriptions that are, you know, just ways to unlock different features into an application. Think about music, services like Spotify, obviously. Video, podcasting, etc. So if you're trying to build an application in that field for creators, definitely think about monetization using something like Unlock. An example here that is really powerful, I think, is the example of DeFi Robot. DeFi Robot provides trading tips and mechanisms to automate, you know, some of the trading. And what's interesting about that membership, it's using Unlock, obviously. On the main net, the monthly membership, if I'm correct, is about $300 or almost $300, which is a very pricey one. But once you have the membership in your wallet, you can access a dedicated telegram channel, as well as access some key features into the application. At this point, DeFi Robot, which is a pretty simple application, is making about $150,000 in annualized membership revenue. So again, if you build these things right, that's actually a very significant revenue opportunity for any kind of community or software application there. These time-based membership we talked about a little bit are not necessarily recurring, but they are kind of time-limited. So think of it as, you know, seasonal or even sometimes perpetual memberships that, for example, give you access to a Discord or Telegram. You can do some of that. Obviously, what's interesting here is like at Unlock, when you create your membership contract, you can choose the currency. And so since that kind of time-based membership is really used in the DAO space, there's something really cool about using the ERC20 currency of the specific community as the pricing mechanism. An example of this is Cabin. So Cabin is a project that actually launched two days ago. It's a network CD. It's basically a community of people that have some kind of co-living places and they have a membership where if you are a citizen, and that's how it's called in the membership, you get access to some specific airdrops, specific features that are allowed only for Cabin members. What's interesting here is like what they've built is a system where if you have a thousand Cabin tokens, the membership is free. And for this, they actually use a hook system that we'll discuss in the last section of this presentation. On-chain certification, we talked about this earlier, your diploma, the fact that you've taken a course, that you maybe attended a hackathon, non-transferable, obviously, critically, but also time-limited most of the time to make sure that your knowledge are up to date. An example of people that are using Unlock for this is a team called PlannerDAO that have created the Certified Digital Asset Advisor, which is basically a proof that you went as a financial advisor through some education around cryptocurrencies and around crypto assets or digital assets altogether. And to date, they have certified over a hundred financial advisors that went through that curriculum and in the end received one of these NFT as a proof of completion. What's interesting about these NFTs is like they can be represented or added, for example, to a LinkedIn profile as a way to show, again, to your potential customers that you are certified here. So building a certification application, I think, is also one of the things that we were excited about to see people do in the ecosystem. We talked about gaming briefly. This is a very popular game in the Web3 space. It's called Pixels. It's a multiplayer game built on blockchain. And they use Unlock memberships as a way to create these in-app purchases. And you can have different kind of feature into the application that are time limited. And if you acquire these NFTs, then you are able to actually do certain things inside of the game. So really, if you're building a game, think about using time limited NFTs as a way to do this. Another example of loyalty, another example of use case is the ring around loyalty. One of the examples that we want to highlight here is a company called Stakes, which is basically building a loyalty program around a restaurant brand or chain. And what's interesting here is once one of the customers, you have one of these NFT, you get some priority access to a reservation system that allows you to book restaurants and be treated as a premium customer and access to a restaurant.
Chunk 4 transcription: to some premium table, maybe free drink or dessert, and a ton of other possibilities that each restaurant might offer to their customers. Finally, attendance NFTs, sometimes called per app in the ecosystem. It is basically a system, it's basically an NFT that someone can earn if they have done something, it is valid forever. And what's interesting here, it can have dynamic metadata attributes. We talked briefly about them, but still Unlock is usable for a PFP project from one to 10,000 plus. Static or dynamic NFTs can be minted on demand by users or can be airdropped and obviously supported on all of the networks that Unlock supports. Tales of Elettra is an example of a collectible that was built using Unlock. And what's really interesting about Tales of Elettra is like you can see here examples, each of these avatar actually has a component of both the avatar and so-called weapons, which are both NFTs. And if a given address or given user owns both an avatar and the weapon, the weapon will show in the background of the avatar. You can see here, for example, the arrow and the bow displayed behind that wolf. If the user of the NFT were to sold the weapons, then the avatar would not have the bow and arrow. It's kind of dynamic based on this. And I think this is a very powerful tool. Just a reminder for everyone who's joining now, Unlock protocol for memberships and memberships are a very core primitive to lots of businesses, can be used from even ticketing all the way to digital collectible, to recurring subscription, certification credentials, gaming, loyalty, attendance NFTs. Really, you have to think about Unlock as a framework for NFT memberships and memberships can be lots of different things. So thank you very much for listening to me until now. And let's jump into the right section in a couple of minutes. Let's now talk about the Unlock ecosystem and the developer tools that we put for people to use inside of their applications. So first of all, quick reminder, Unlock is a protocol. It's a smart contract system. Of course you can, and you should, if you can, just use the smart contract and not rely on anything that was built on top of us by the Unlock Labs team. However, if you want, and we think it's a good way to kind of scaffold your application, you can start by using some of the tools that we've built. For example, we've built two really important front-end applications. The first one is what we call the Unlock dashboard. The Unlock dashboard is a way for what we call lock managers to deploy their membership contract, their lock. From there, they can also manage the contract. They can change, as we've seen earlier, the contract is updatable, so they can change some settings, the price of a given lock, the number of memberships, the duration of these memberships, et cetera, et cetera. They can also manage members. So they can see the list of existing members. They can change the membership status of someone, can refund, can cancel. They can also airdrop membership NFTs to specific addresses, or even use some of the features that we built, such as the walletless airdrop, where it's basically airdropping NFTs by email. The recipient gets an email with a claim link that they can use to bring the NFT from a placeholder address to their own wallet. Obviously, as I said earlier, these membership contracts are NFT contracts, like, I mean, they're ERC-721, which means that you can also customize the metadata on this NFT, starting with the image, obviously, or even set custom attributes for the type of membership that you have. So for example, if you're organizing an event or building an event platform, there's a set of metadata specific to events. So for example, the location, the starting date and the starting time, the finishing date and finishing time, but also, for example, things like, you know, description of the events. We can say, okay, this is a conference happening on blah, blah, blah, with the speakers X, Y, and Z. Similarly, we also have built a second really important application that is called the checkout. The checkout UI is not meant for lock managers, but really it's meant for the soon to become members. It's a way for people to mint NFTs by purchasing them. And I say purchasing, but in some cases, these NFT can be free, as long as they're claimable by the end users directly and not only are droppable by the lock managers, you can use the checkout UI. The checkout UI is a flow that has multiple steps that obviously starts with connecting the wallet and finishes with minting the NFT. But during that flow, the lock manager can configure it so that some metadata is collected as well. So if, for example, if you're organizing an event, as we talked about, you might want to collect, you know, information about the attendees, the first name, last name, or email address. That is something that you can easily do with the checkout. We have a way to configure this with a kind of a no-code tool accessible from the dashboard, the checkout builder, but you can also configure this in code.
Chunk 5 transcription: code and we'll talk about this a bit later. Finally, as I said earlier, Unlocked Smart Contracts are built in a way that they instantly support payment using FIAT, so using credit cards specifically. You can do that from the dashboard, configure things from the dashboard, and then users can enter their payment info from the checkout UI. We also support some interesting mechanisms such as swap and purchase. Swap and purchase is basically a flow on the checkout that user can pick if they don't have the currency of the membership, but they have another one that can be swept on the same network on the same chain for the one required by the lock. Let's take an example. Maybe I deploy a lock that is using USDC as its currency on Polygon. But myself, I've actually never bridged USDC token to Polygon. I only have Matic token on Polygon. It's not a problem. The checkout flow will actually include a one-click option for me to swap, so pay with my Matic that gets swept into USDC into a membership in a single transaction. I don't have to leave the UI. I can just do that straight from the checkout UI. That's the two tools, the dashboard and the checkout that are basically UI in front-end that you can use to start and get started or also use into your application. We also have built a lot more developer tooling that are directly useful for you developers to integrate unlock into your applications. First of all, we mentioned this earlier, the concept of subgraph. As you know, the graph is a protocol for on-chain data indexing, but beyond that. We have built custom subgraphs for unlock smart contract. These custom subgraph include obviously representation of the locks, the smart contract. You can get all of the information from a smart contract at once using the subgraph or multiple locks at once from the subgraph, but also the memberships and they're called keys in the context of unlock. You can retrieve all of the members on a given lock in one single transaction. I think the subgraph actually has, and it's not an unlock limitation, but it's a subgraph limitation as a maximum of 1,000 keys, 1,000 items, but you can paginate and do 1,000, 1,000, 1,000 and add things up from there. The subgraphs also include what we call receipts, which is basically an object that you can use to identify what payments were made on a smart contract. Another useful developer tool that we have introduced is called unlock.js. This is a JavaScript and TypeScript actually library that retrieves data from the chain. You could use that instead of the subgraph, but it also includes the ability to trigger transactions to change the state of the chain. It is based on Ethers.js. By the way, you could very well use Ethers with a specific lock, but it does provide a lot of syntactic sugar for things that would require a lot more manual handling. You should check out unlock.js if you want to deploy locks, for example, or if you want to purchase memberships, this is definitely possible. Again, you could very well use existing libraries like Ethers or Web3.js or others in other languages, if that's easier for you. Unlock.js is completely optional. Another tool that we built is called the Paywall. I mentioned earlier the checkout UI. The checkout UI is basically a UI that can be displayed using two mechanisms. On one side, it can be done as checkout URLs, so standalone web pages that can be opening in a new tab for the user, or it can be used as part of the Paywall, which is a JavaScript library that can be embedded inside of any web application. The Paywall obviously supports signing with them and includes all of the checkout steps. This is really useful if in your application you want to, for example, identify users or allow them to purchase membership without sending them to a different web page. That Paywall is obviously completely configurable using a JSON object. You can customize the title, the image, the number of locks that are displayed in the metadata collected, for example, as I mentioned in the previous step. Finally, a last tool that we have, which we think is really useful, actually there's a couple more tools, but for this presentation, I will only clarify these, is the concept of hooks. As I said earlier, the smart contract themselves are programmable. You can change the behavior of your membership contract using these hooks. There is at this point seven hooks on the contract that can all be called or implemented for your specific lock and change the behavior. Some of the popular hooks include, for example, the on-key purchase, which is basically a hook that gets triggered when someone purchases a membership and when it's about to be minted. That hook is really interesting because it allows you to do things like check that the user meets certain criteria. For example, are they on a specific allow list? If so, then yes, they can complete the purchase of dimension or no, it will fail the transaction. Another characteristic of that on-purchase hook is that it includes the ability to customize the type of transaction that you want to make. For example, if you want to make a transaction, you can do that by clicking on the button, and then you can click on the button to
Chunk 6 transcription: is the price that the user pays based on certain characteristics. So if the user is on the loudest of discounted people or if they have entered a discount code at the time of purchase. We'll actually come back to this specific example in the last section of this presentation. And so please jump to that step if you're interested in this. One last thing that I want to mention is existing integrations. Unlock, the public lock, sorry. In the unlock protocol, the public lock, the membership contract is just like any other ERC721 contract. It is implementing the base ERC721 specification, including stuff like transfer and everything. So it does work with any existing framework, like Ethers, Third Web, Web3.js, Wagme, et cetera, like I mentioned. But also any kind of wallet, whether it is a proper Metamask, hardware wallets, obviously. But also things like Magic or Privy if you want to use these wallet as a service kind of approaches. Finally, Unlock has been integrated by different teams inside of their application or by us inside of the other applications. I mentioned Magic as an example. That's something that we have a tutorial from on the Docs website. Stripe that lets you connect with Stripe Connect, as it's called, to receive payment in crypto. Superfluid, the streaming protocol. Uniswap, that's for something that I described earlier as the swap and purchase flow. E-Fast that allows users to download iOS, Android, passes into their phone, represents NFTs, et cetera, et cetera. If you're building an integration into an existing platform, please get in touch with the team. We'd love to hear from you. We'd love to help you build this. I want to show you another kind of overview of the Unlock Protocol ecosystem. So basically, these are all applications that either work or have integrated Unlock natively. So you have a bunch of protocols. So for example, Lit Protocol is a token gating protocol that does encryption. You can very well use the Unlock membership to decide whether a specific piece of content should be encrypted or not encrypted using Unlock. Works with Superfluid, I mentioned earlier. Works with Livepeer. Actually, we'd love to see Livepeer integration. So Livepeer is a video protocol, a streaming video protocol, that you could use to token gate live streams. A bunch of applications also use Unlock. So you mentioned, I mean, Guild is a good example. Coinvise are two of the UIs that you can use as a creator to deploy or manage, rather, membership and connect these membership to your community. You can use stuff like Beam for video or Monetize to integrate in Notion, et cetera, et cetera. We also have a bunch of agencies and friends that are using Unlock directly into their application. And so you can see some of the names there. Finally, there is a ton of projects that are built on top of Unlock. You can use that list. And as a reminder, we actually are available on nine different networks, which mean that one of them is missing from that slide. But EtherMainnet, Polygon, GnosisChain, Optimism, Arbitrum, Celo, Binance, Palm is the one that's missing from here. Again, check our docs. We have all of the links with this. And by the way, on all of these networks, we've obviously deployed the corresponding subgraphs or any of the other smart contract that we would use, such as the credit card or system, et cetera, et cetera. Let's move on to the next section after this. Let's jump right into our first tutorial of the day, how to build a token gating application with Unlock, obviously on the front end only. So we're not going to write any smart contract code. We're not going to write any solidity code. We're only going to focus on building a front end application using JavaScript technologies. Let's actually start first look at the basic app that I built. This is a regular Next.js application. I'm starting from there. And what I want to achieve is basically have this section here be a members only section, so only visible if the user has authenticated first and obviously if they have a membership in their wallet. If they don't have a membership in their wallet, we will prompt them to purchase one. And obviously until we know who the user is, we'll add a mechanism to authenticate users. So let me actually do a quick show of the application. This is the basic app component. Again, vanilla Next.js application. It has a single page, which is a page here in a single content section, which has a little bit of content that we want to token gate. Let's get started by first installing a couple dependencies here. And I want to install two dependencies. Specifically, I have them here. Yep, here they are. Wagmi, which is a JavaScript, actually a React front end, sorry, a React hook framework for dealing with smart contracts and connecting wallets. And Ethers, which is a low level JavaScript library that interacts with the same smart contracts in wallet. So I'm going to just go ahead and install these two things. Pretty basic.
Chunk 7 transcription: and then we'll go look at our app. Here, what I want to do first, obviously, is add the dependencies that I just installed. So I'm going to just do that at the top of the file, nothing too fancy. Then I'm going to create what is called a WADME client. That is what's going to use... that's what our application is going to use to interact with the wallets. And here we see we're pressing this little property auto-connect true, which is basically allow users who have already connected to stay connected and auto-connect when they load the page. But then we're also passing a provider. The provider is the network component, if you want, that allows the application that we're building to connect to the blockchain. And we're using the RPC endpoint that Unlock provides for development purposes. You're more than welcome to replace that line specifically with Alchemy, Infior, or any of the RPC provider that you actually recommend using your own as soon as you hit production. We see here we have a little network component here, and we're actually going to import that from a config... a config file that we have... from... and I can't type today... from a network. And obviously I need to remove that little N from the config file. Let's go look at the config file. There's not much in it for now, just the network. Once we have this, obviously, the next... Oop. I think that's what I want to do. Once we have this, we need to wrap the component here inside of what is called a WAGMI provider. And this is a, you know, a React provider for specific context, which allows us to connect on the application. So that's the basic setup here. Let's double-check, but the application is still accessible. Nothing's changed because we haven't actually done anything from a code perspective. Let's now look at our index page, and that's actually more interesting here. What we want to do on that page is obviously get started by make sure that the user is connected. For this, we will use other components from the WAGMI library. So I'm going to just add these dependencies right away at the top. So first we're going to use useAccount, which allows us to get information about the user that's connected, and useConnect, which lets us connect the user. I'm also using this injected connector, which is basically a way to retrieve the injected wallet in the web browser. So I'm just going to include these two hooks here. And I'm going to change the behavior of the application a little bit so that if the user is not connected, we will basically add a button to let the user connect, which seems pretty straightforward. And then we're going to just change one thing for now, which is if the user is connected, we will show the content. And obviously I am missing a little parenthesis here. But we'll also add not just the content, but a button to disconnect. And since we're going to have two components in the same element, we do this. And for the disconnection, I'm actually going to use another feature from WAGMI, which is this disconnect function here. So that's pretty much it for now. Let's go refresh the page. I'm already connected because I connected before. So what I'm going to do here is disconnect from here. So you see that happening here. And I'm going to disconnect from here. So if I refresh the application now, I only see this connect button, obviously, because I'm not yet connected. I click connect. My wallet should have prompted, but again, it's not connected earlier. It is not prompting me to connect, but I'm connected. And then I can see the content. So again, fairly straightforward. Now, what's interesting, though, is we now have a connected user. We know what the user's wallet is. And so that's going to allow us to move to the next step, which is to add a special component, which we'll call basically, you know, something like TokenGate. And so let's actually do that. I'm going to add a new component, TokenGate.tsx. And this component is going to be fairly simple. It is just going to, for now, return the children. So it's actually not tokening anything for now. It is just serving the content that it has. And what we'll do now is actually wrap the content inside of the TokenGate component. I just want to make sure that I'm including this at the top of the file, as you can see here. And so now the content component is still here, but this time we wrap it into the TokenGate component, which will have the logic of making sure the user is connected and has access. For now, again, nothing changed. Oops, mismatched between what the server shows, but if I click here, I can now still show the content. But this time what we have is the way to go through that, through this TokenGate component. This component is going to be a bit more complicated. Oh, actually, I forgot to add the props here for the children. So this component itself is going to be a little bit more complicated, and so we'll get started working with this. So here we're going to use
Chunk 8 transcription: We're going to use, again, the Wagme library. We're going to use useAccount, which we'll use to retrieve the wallet address, but we'll also use this useContractWid, which is a hook that lets us retrieve some information about a smart contract. What we'll do here is also include another library that we haven't used so far, and I'm actually going to install it, which is this component that Unlock provides, which includes the API. The API is, if you want, the API description of what the smart contract has. I forgot to say add here, and I have a quote that I need to remove, but I'm adding this dependency now. It's going to take a couple of seconds to install. What's cool about that now is that I'll be able to use this into the code. Let's actually do this. I'm also going to add—actually, that's it for now. The first step is to then now add a bit of logic here, which I'm pasting here. Lock address, that's going to be another configuration that will come to this, and address is going to be the user's address. Actually, let's retrieve that directly from the useAccount component. I'm just going to do const address equals useAccount, and then lock address will actually include this from our config as well, which I'm going to just add in a minute here. I'm going to now write it in the config. The lock is the membership contract, as we discussed earlier, and so I'm just going to add an address here. Other than the membership contract that I've deployed before, there is no need to go through that process here, but know that you can easily do that from the unlock dashboard. Let's actually go back to the TokenGear component. We have this interesting hook now that is being called, and it's going to retrieve some data. We'll look at the data in a second. If there's an error, this variable is going to be set to true, and if it's loading, this variable is going to be set to true. What we're passing as argument is first the lock address, the smart contract address that we're retrieving, the ABI of the public lock version 13. That's the latest version of the protocol that I've used here, and the function I'm using here is called balance off. This is a way to retrieve from the contract if a given address that we're passing as argument has any membership token that is valid. It will return zero if the user doesn't have a valid or if they have one that's expired, and obviously will return one, two, three, four, five, depending on how many valid membership the user might have. Let's actually now add a little bit of logic here. Obviously, if the page is loading, we don't actually want to show the children right away. If there is any kind of error, we also don't want to show the content. The last step is if data equals to zero, we will show something like you need a token to access this content. Let's save this, and let's actually go to our page. It already self-refreshed, but you can see here that it says you need a token to access the content, because as a matter of fact, and I'm just going to console log the data object here so you can all see what is in there, it's a so-called big number, and it's a JavaScript object, and this is the exceptional value of zero. At this point, I don't have a membership, and I cannot see the content. Really, nothing, this is what we expected. I guess the next step is to add another function here. Rather than actually tell the user, hey, you don't have access, we'll basically show them something along the lines of, if you don't have access, well, you need to buy a membership. I'm going to replace this with a button that's called Buy Membership, and I'm going to add a new checkout function to our component here. This function will get started with an empty version of it. I'm just going to do nothing in here, and we'll look at implementing this. For this, we're going to use another library that the Unlock team provides, obviously completely optional, but it makes things much easier, which is the Paywall library. The Paywall library is basically, as the name indicates, a quick little paywall that you can add to any web page that allows users to check out or purchase a membership. I'm also going to add another useful package, which is called the Networks package from Unlock, that has all of the configuration for Unlock. They're, again, completely optional, but it simplifies things greatly if you use it. Let's go back now to the code here, and let's look at what we're going to put in the checkout.
Chunk 9 transcription: First, we're going to do an interesting thing, a couple of interesting things. We're going to load the provider used by the connector. Connector is actually something that we get from user accounts, and that's the object that connects to the user's wallet. We're going to get that provider, and then we'll instantiate a paywall object. Again, that's coming from the unlock library. I'm just going to add this. I didn't add that at the top as a requirement here. And paywall config and networks, actually networks, we have it from the package that we just installed. So I'm going to add that as well. And the paywall config, we'll get it from the configuration. And we'll go at that in a minute as well. So I'm just going to replace this line with this. And paywall config, here I'm just going to copy-paste what I have already built before. And this is basically a JSON blob, and you can find all of the details on how to build this inside of the unlock documentation. That lets you configure how the paywall should behave. It should have multiple locks here, but in this example, just one. It could have multiple locks, just one here, with the lock address on the network number five. We're going to skip the recipient step, assuming the user is purchasing for themselves. And then we're going to put a name, combine membership, or my app membership maybe seems more accurate here. And we're also going to use what we call the specimistic, which is basically we're going to require the user to wait for the transaction to be mined before returning to the application. Let's go back to the TokenGate component now. So we have this paywall, but that is not enough. What we need to add is the ability for the user to load the checkout. I'm just going to add this here. And basically, load checkout model, it's an async function that's going to show a little checkout model. And we'll go look at this right away. So let's actually go to the application. You see now I have a button here, which is really useful. And I still have my console log, which makes this a bit messy, but it's fine. If I click here, what's going to happen? It's going to load the checkout model. And I have my app membership and the smart contract that I'm using here at the address that I specified earlier. You can verify this is the right address here. So this is all great. But let's actually go look at the rest. If I close, nothing happens here, which is what's expected here. Result, what's interesting is if there is a result, we will get inside of that result object a hash. And what's interesting here is we want to use the hash in our UI. I'll explain what it is in a second. So we're going to use React's use state. And here, what we want to do is basically have a nicer UI to show the user that it's important to wait, that they are waiting for donations. So even though they might not have a membership, if they and let's remove this, if they have just bought one, we are going to wait a couple of seconds for the transaction to confirm. And then once this gets confirmed, hopefully they'll be able to see the children. All right, so we're ready to do the final test on this application. And I'm just going to click Connect here. At this point, my wallet is connected, which is exactly what I want you to do. And I'm going to click the Buy Membership button. You see this little pop-up shows up. And I'm going to click Next. And this is a renewal because I've probably already purchased a membership before. So we'll have to send this transaction. We can go see it on the Block Explorer, actually. And so you can see that a blockchain transaction is being minted. We'll have to wait a second or two here. Oh, this has been mine. We usually wait for a couple more blocks inside of Unlock. So I can close this, hopefully. And you see that now I can access the content. So I refresh the page here and click Connect. You see that I can see the content. Once my membership is going to have expired, which should be actually, you know what? No, it should be shortly. I will have to reconnect and buy again. So this is it for today. Let me stop the video here. How to use Unlock in smart contracts. Here we're doing something a bit special, which is we're going to implement a hook to modify the behavior of the public lock, which is the membership contract. What we want to do here is something actually pretty simple. We want to make sure that every time a new membership is sold, the price of the next membership goes up a little bit. This is usually called a bonding curve. And this is a good way to implement what is called a discovery, a price discovery mechanism, where basically every time a new membership is being sold, the price goes up. And at some point, you would assume that no more memberships are being sold because the price is now too high. So let's go ahead and get started. So to do this, we'll create a new contract.
Chunk 10 transcription: a new folder here, which I'm doing here. Oops. Okay. I already have, well, it's actually doing example here, and we'll just CD into that one. I already have the bonding curve locally. Then we'll run a command called npx rhat, which installs the hard hat tool set. Hard hat is one of the popular tool sets in the Ethereum world. You should definitely consider using it for any project that you use. It is not related to UnlockedIn, so I'm here just completing the default options. And let's say yes, we'll install the toolbox here and wait for a few seconds. When hard hat does this, it actually does install not only a bunch of dependencies, but also creates a scaffold for a project, which I think is going to be very useful for us as we're going to go into this exercise. So let's wait a couple of seconds for this to complete. In the meantime, I'm actually just going to open the code here and show you what's in here. There's actually a contract that is kind of 12-doc. It's very confusing, but it's not related at all with Unlocked and we'll actually remove that file in a second. It also has a test, which basically tests the behavior of the contract that we're going to write. It also has, interestingly, a configuration file for hard hat, and we'll just actually start looking at this. So I see that the dependencies have been installed. We'll install two more dependencies. One is the unlock contract package. So yarn add unlock protocol package. And then we actually have a specific unlock plugin for hard hat, which we'll install right after this, just to make sure that everything works as we expect. Once we have this, we need to modify our files to make sure that they include all of the required setup. And so we'll basically have to do one simple thing, which is add the unlock plugin here to make sure that it's going to be used. And that should be pretty much it. So let's actually do yarn run test, just for the sake of making sure that everything is working as we expect it. Yarn run hard hat test, sorry. And, oh, we're missing a bunch of dependencies here, which we'll just install. That's actually yarn as this, so yarn add. And that should work. There's a quote somewhere. Yarn add here. So it's installing all of these extra dependencies, which are used by hard hat specifically. So let's give it a second for this to complete. But once we're there, what we're going to do is basically start by cleaning up that code. So we're actually going to use, or rename that, rename to maybe bonding curve, bonding curve, oh, I can't type, bonding curve hook.sol. And so that means that we'll pretty, rename the contract as well to bonding curve hook. And we'll remove pretty much everything that's in it. The constructor will just maybe not even have anything in here. Let's not make it payable, because it's actually not going to be useful to be payable. And so that's the most basic version of our hook here. We'll also look at the test, obviously, rename that bonding, I can't type, curve hook.js. I think that's fine. And we'll go modify the test. So quick indication. So as I said, we're going to modify the behavior of the lock and we're going to modify the behavior of the lock when a new key, a new membership is being purchased. For this, we actually have to implement two function in our smart contract. One function is called on key, sorry, it's called key purchase price. And I'll explain in a second what this function does. And then we'll have to implement a second function, which is a bit, I mean, pretty basic, which is the on key purchase function. So what the first function does is the lock, the membership contract calls that function with the, whether it's the sender of the purchase function with the recipient address, the referrer. And again, these are concepts that are specific to unlock, you should check it out in our docs, as well as a data argument. And then this function is expected to return a key price.
Chunk 11 transcription: here, what we'll do is return what is the default key price. So basically, we'll make sure that we return the normal key price. And I realized I forgot to include the interface file for this to create. The second function is the one that actually is called at the tail end of the purchase function when the purchase has been successfully achieved. And that's the one that we'll use here to modify the state of the contract. And so to do this, we'll just basically do something pretty simple, which is go read. I mean, we'll basically create something where we'll have the lock that we retrieve as the sender of the transaction that calls this specific contract. And then we'll retrieve the price. We'll multiply by two here. The price doubles every time. And we call the update key pricing function to change the price. So basically, we call this function, we change the price, and obviously, we keep the same currency. Token address is the currency of the lock, which could be any FC20 or the base currency of the chain. So our contract is actually pretty much implemented at this point. There is not much else to do. The next step is obviously to modify the tests. So here, what warray. We pass arrays for each of these values so actually let's just for sake of clarity do this we pass an empty an array for each of these because you could actually call this function with multiple values to purchase multiple memberships in a single call. Once this transaction has been executed we'll just verify that the key price has been successfully changed to be now double what it was so we had a key price of one gui and now we should have two gui. That's pretty much it code is ready now so the next step is to run our tests which I'm going to do here right away it compiles oh and we have obviously an undefined argument here because lock args is actually not exposed so I'm just going to keep that value that I had before I think that's going to make things easier and so this time if I run the command it should compile fine and you see that the test passes. So we're done for that exercise you can see that we've created a lock first in the code here we've attached a hook that basically changes the price of the membership every time a new membership has been purchased. Just make sure that if you're you know if you want to learn more about this go check our docs we actually have a specific tutorial so the docs are at docs.unlock-protocol.com we have a specific tutorial for how to create a I mean hooks the one that is on our website is the one to create a password protected purchase so please do check it out it provides more detail around hooks if you need them as well in our docs you can find all of the reference for the API and the protocol itself so please use this if you want to start implementing anything with Unlock. Thank you very much see you soon! you




チャンク0書き起こし： 

皆さん、おはようございます。このワークショップにようこそ！今日はUnlock Protocolについて学びます。このワークショップは、Unlock Protocolの上に構築したい開発者やハッカソンの人たちに捧げられたものです。ここでは、Unlockとは何かについて、簡単なアジェンダを始めます。まず概要から説明し、次にエコシステム、グラフのサブグラフを含むどのようなツール、そしてどのような統合が存在するのかを見ていきます。そして、最後のセクションで2種類のチュートリアルについて説明します。一つはフロントエンドのユースケースとその作成方法、もう一つはスマートコントラクトの統合のユースケースとフックの作成で、これはUnlockのスマートコントラクトに非常に特有なものです。

まず最初に、私自身のことを少しお話します。私の名前はJulien Genestouxです。Unlock ProtocolのCEO兼創業者です。その前は、実はSuperfeederという会社で働いていて、2016年にMediumに売却されました。SuperfeederはRSSフィードAPI、RSS、オープンウェブの中核となるビルディングブロックを構築していました。そして、Unlockをオープンウェブのもう一つのビルディングブロックとして考えなければなりません。私は大きなオープンソースの提唱者です。W3Cの招待専門家であり、グラフ評議会のメンバーでもあります。ネット上ではjulien51で検索できますし、私のサイト ouvreboite.com, O-U-V-R-E dash B-O-I-T dot comでも検索可能です。

では、さっそく本題に入りましょう。アンロックプロトコルとは何ですか？アンロックプロトコルとは、メンバーシップのプロトコルです。どういう意味ですか？と聞かれるかもしれません。Unlock Protocolは、簡単に言うと、会員制を作り、アクセスNFTや会員制NFTを数分で販売するためのシステムです。このシステムを使えば、開発者はメンバーシップ、サブスクリプション、チケットソリューション、トークンによるウェブサイトへのアクセス、認証、ゲームなどを作成することができます。これらについては、また後日ご紹介します。MITライセンスによる完全なオープンソースであることは明らかです。コミュニティ・ガバナンスがあり、DAOとガバナンス・トークンを持っています。

Unlockの上に構築する場合は、私たちのDAOに参加していただき、プロトコルの将来についての意思決定にご協力いただけるようお願いしています。Unlock Labsで構築したアプリケーションのセットがありますが、他の人たちもライブラリや開発者ツールで同様に構築しています。2018年に私によって設立されました。そして現在、Google、Facebook、GoDaddy、その他複数の企業から多様な経験を持つチームと、世界中の人々が集まるグローバルコミュニティを持っています。では、会員制とNFTについて具体的にお話ししましょう。では、メンバーシップを表現するために、どのNFTを使ってもいいのでしょうか？また、特にここでは、人気のあるプロジェクトにお気づきかもしれません。答えは、「いいえ、いけません」。つまり、できるのですが、してはいけないのです。なぜかというと、デフォルトのNFT、特にコレクタブルNFTは、できることが限られているからです。例えば、第一の制限は、永久に有効であることです。永久に有効なのです。

しかし、何らかのメンバーシップを作成する場合、時間的な制約があったほうがよいでしょう。NetflixのメンバーシップやAmazon Primeのメンバーシップを考えてみてください。これは時間的制約があります。1カ月間有効で、さらに1カ月、1カ月、1カ月と更新され、お金を払う限り有効ですが、永遠に有効というわけではありません。同じように、資格について考えてみましょう。例えばアメリカの運転免許証は、陸運局の会員証であり、期限が決まっています。5年間有効で、その後は更新して、まだ運転の仕方を知っていることを証明しなければなりません。ですから、通常のNFTを使ってもうまくいかないのです。このように時間的な側面があるため、開発者は、アプリケーションやコミュニティが毎週、毎月、毎年、どのようなスケジュールで持続的な資金を得ることができるのか、定期的な収入を組み込むことができます。

NFTの期限は何度も切れるため、NFTの契約と密接に関連するロイヤリティの概念から、より継続的な収入に移行することができます。同様に、Unlockでは、スマートコントラクトの中に、暗号による支払いだけでなく、例えばEFC20トークンによる支払いにも対応できるような機能をいくつか組み込んでいます。さらに、クレジットカードを使ったフィアットペイメントにも対応しています。また、オンチェーンでのアクセス制御だけでなく、オフチェーンでのアクセス確認も可能です。これらのNFTは、それぞれ署名することでその真正性を証明することができます。そして、その署名から、例えば、コンサートや会議などに参加する場合、誰かが会場にアクセスできる可能性がある、あるいはアクセスできるはずだということを証明する方法として、チケットに表示されるQRコードを生成することができるのです。同様に、会員権も譲渡可能なものがあります。

チャンク1の転写です： 
しかし、その他のメンバーシップは、そのほとんどを占めると思いますが、譲渡可能であってはならないものです。Netflixのアカウントは、たとえパスワードを友人と共有したとしても、おそらく譲渡できないでしょう。認証や卒業証書は、間違いなく譲渡できません。卒業証書をある組織から別の組織に移せるようになるのは嫌でしょう。しかし、例えばソーシャルクラブの中には、譲渡可能なメンバーシップを持つものがあることも想像できるだろう。もしあなたが現在そのクラブに所属していないのであれば、そのクラブに所属できる他の誰かにその会員権を譲渡することができ、あなたはもうそのクラブに所属できなくなります。もちろん、アンロックで作った契約はESC721で、ほとんどの場所で使われているデフォルトのNFT契約と同じです。しかし、それはトンデモない特性を持って構築されています。コレクタブルについて考えるとき、契約そのものが不変であること、つまり初日に契約書に書かれていることが永遠に続くことが重要であり、もしかしたら重要かもしれません。しかし、メンバーシップをより一般的な概念として考えた場合、契約の振る舞いをアップグレードしたり変更したりすることができれば、実際に面白いかもしれません。例えば、メンバーシップの価格が上がるかもしれませんが、これはUnlockでもネイティブにサポートされていることです。具体的には、Unlockの契約は更新可能です。契約の名前、メンバーシップの価格、メンバーシップの期間、供給、メンバーシップの数などを変更できます。また、特定のメンバーシップを変更することも可能です。場合によっては、メンバーシップを取り消すことができることもあります。せっかくお金を払ったのに、キャンセルして返金してもらったり、他の人に割り当てたりすることもできます。また、契約はアップグレード可能です。プロトコルは時間とともに進化していくので、各コントラクトはアップグレード可能であるべきだという考えから、私たちが作ったものではありません。つまり、メンバーシップ契約を展開した特定のクリエイターは、DAOによって新しいバージョンのプロトコルが利用可能になった場合、そのプロトコルにオプトインすることができるはずです。最後に、これは本当に興味深い点なのですが、プロトコルの契約、いわゆるパブリックロックは、プログラム可能です。プログラム可能なのは、開発者がメンバーシップ契約にカスタムロジックを組み込みたいと思うかもしれないと考えたからです。そこで、開発者、そしていずれはクリエイターが、ある特徴に基づいてスマートコントラクトの動作を追加したり変更したりできるように、フックというシステムを用いています。例えば、会員登録時の割引コードをサポートする方法です。例えば、メンバーシップの価格は10ドルですが、ユーザーがメンバーシップを購入する際に、特定の割引コードを入力すると、5ドルや8ドルの支払いで済むようになります。これは、フックの使用によるもので、このプレゼンテーションの最後のセクションで、このことに戻ります。いくつか重要なユースケースを紹介しましたが、より具体的に説明しましょう。先ほど申し上げたように、イベントチケットです。カンファレンスへのチケットやコンサートへのチケットは、会員制のもので、一回限りの会員、つまりその特定のイベントのためだけの会員ですが、会員制です。また、ある種の定期的なサブスクリプションを構築することも可能です。NetflixやAmazon Primeの例を挙げました。これらはその良い例です。SubstackやPatreonを使ってクリエイターを支援している人なら、定期購読のアイデアをご存知でしょう。また、時間制にすることもできます。例えば、アプリケーションの中に季節を組み込むことができます。例えば、あるプロジェクトの期間中だけ、そのプロジェクトを管理するために利用するコホート（Cohorts）があります。このように、基本的には時間ベースのメンバーシップです。認定資格、クレデンシャル、卒業証書について触れました。これらはすべて会員制です。大学や同窓会のメンバーであれば、その年の卒業証書を手にすることができます。1年間、イーサリアムを使ったトレーニングを受けた人たちの一員であり、その認定を受けることができます。この認定証は1年間有効です。認定を受けたことを証明するために使うことができますが、その1年が過ぎると、知識が最新でなくなっている可能性があるので、期限切れと考えるべきでしょう。また、ゲームの文脈でも役に立ちます。ゲームでは、レベルを上げるとアンロックされますよね。これは、そのレベルへのメンバーシップです。これをメンバーシップと考えるのは少し奇妙ですが、メンバーシップとは何かという核心から考えると、本当にそうなのです。ユーザーとして、プレイヤーとして、あなたはグループの一員なのです。レベル2にアクセスできる人々のグループの一員です。また、特定のゲームアイテム、つまり剣などにアクセスできるグループのメンバーであることもできます。また、ロイヤルティプログラムの文脈でも有効です。つまり、航空会社のマイレージプログラムのようなものだと考えてください。あなたがそのブランドに忠実であることを示す会員証のようなカードを持っていて、その例ではあなたは忠実な顧客として扱われるべきです。アンロックは、出席NFTや修了証明、どこかに行ったという事実、結果的にグループのメンバーであることを示すのにも使えます。

チャンク2の転記：
チェーン上で何かを記念する方法。そして最後に、アンロック契約は、デジタルコレクタブル商品、例えば以前見たPFPコレクションや、その他あらゆる種類のNFT、通常のコレクタブルNFTにも使用することができます。時間制限、タイムリミット、タイムバインドという側面も、実は非常に有効です。また、例えば、時間と共に進化するダイナミックなNFTを作りたい場合、ユーザーが延長したり更新したりしない限り、PFPが古くなることを想像してください。さらに具体的なユースケースを掘り下げてみましょう。チケット販売では、今のプロトコルの展開からすると、チケット収入の100％がクリエイターやイベント主催者に入ることになります。プラットフォームが割を食うようなことはありません。主催者は、チケットの流通を完全にコントロールします。そして、もし彼らが望むなら、潜在的に二次市場を完全にコントロールすることができます。チケットの譲渡を避けることもできますし、特定のクリアリングハウスを経由して譲渡することを義務づけることもできます。また、スマートコントラクトは、イベント前、イベント中、イベント後の参加者に相互運用可能な体験を提供することも可能です。あるイベントのチケット販売がNFTであった場合を想像してみてください。例えば、イベント前にDiscordサーバーに接続し、他の参加者全員に参加するために使用することができます。あるいは、例えばホテルの部屋を予約するために予約サイトに接続し、チケットを持っていることを証明することで、その分の割引を受けるときに使うことができます。そういうことがイベント前にできるわけです。イベント終了後、あるいはイベント中に、カンファレンスのベストセッションを投票できるシステムを構築する方法として、これを利用することができます。そして、スナップショットのようなツールを使って実際に投票できるのは、有効なNFTを持っている人たちだけです。従来のチケットシステムを使うとしたら、構築するのは本当に大変なことです。イベントチケットのアプリケーションに接続するアプリケーションに認証を構築する必要があります。そして、彼らはおそらくこのためのAPIを持っていないでしょう。また、たとえあったとしても、その情報にアクセスできる人を制限することができます。また、イベント終了後にも有効で、例えば、来年のカンファレンスでは、前年に参加した人が割引を受けられるようにするといったことが考えられます。NFTをチケットに見立てた場合、スマートコントラクトをプログラムすることで、昨年のチケットを持っている人は10％割引になるようにすることが簡単にできます。チケットは、特定のコンセプトに興味を持つ人々のコミュニティとつながる会員証です。Unlock for ticketingは、暗号空間やEthereum空間の複数のカンファレンスで使用されてきました。Dapkonは、今年もベルリンで9月11日から9月13日にかけて開催されるカンファレンスで、私たちはこれを紹介しています。Dapkonは昨年もUnlockを使用しています。参加者は約1000人で、ほとんどが暗号のエコシステム関係者です。ここで興味深いのは、彼らは明らかにUnlockを使用していますが、特定のチェーンでUnlockを使用していることです。まだ話していませんが、Unlockは9つの異なるEVMネットワークに導入されています。EthereumメインネットやPolygonはご存じでしょうが、DapkonはGnosis Chainを選びましたので、このスマートコントラクトを展開するには非常に良い選択肢だと思います。また、OptimismやArbitrum、その他にも複数の選択肢を用意しています。これらはすべて、私たちのドキュメントに掲載されています。Dapkonが興味深いのは、彼らが暗号会議であることです。したがって、暗号会議として、彼らがドッグフードをするのは理にかなっています。彼らは、自分たちが書いたり話したりする技術を利用しているのです。この例では、特にUnlockを使用することにしました。また、Unlockの中には、QRコードをスキャンしてチケットの真偽を確認するシステム、リファレンス・チケッティング・アプリケーションも構築されています。このようなユースケースには、とても期待しています。もしあなたが何らかの発券ソリューションを作りたいのであれば、Dapkonの事例からインスピレーションを得てみてはいかがでしょうか。数週間前に台北で開催されたETH Taipeiや、昨年パリのECCでもUnlockが採用されましたが、その他にもUnlockを採用したカンファレンスがあります。ETHワルシャワでは、チケットの発券などにUnlockを使っています。もう1つのユースケースの例として、サブスクリプションの概念についてお話しました。サブスクリプションは、費用やサービスに対するトークン・アクセスを可能にするものです。例えば、Netflixの会員になると、トークン・ベースではありませんが、ストリーミング・サービスにアクセスし、アプリケーションを視聴できるようになります。ジムの会員になれば、ジムの物理的な利用が可能になり、そこで運動ができるようになります。ジムの会員になると、ジムを利用できるようになり、そこで運動ができるようになります。このように、暗号やクレジットカードを利用することができます。ここで重要なのは、ビジネスが会員と直接関係を持つということです。このような状況には、中間業者が関与しません。この2つの間にサービスは存在しないのです。Netflixの例は興味深いものです。Netflixの購読は、Netflix.comのウェブサイトから、またはAppleやGoogleを通じて行うことができます。

チャンク3の書き起こし：
モバイルデバイスで。モバイル端末を使った場合、実は、NetflixとApple、Googleが仲介役となり、条件を変更することができます。そのアプリケーションの動作を検証しない、ということも可能です。これは、Netflixのようなビジネスにとって理想的ではありません。しかし、コンテンツには有効です。Substackについては少し触れました。ソフトウェアの場合、アプリ内課金について考えてみると、その多くはサブスクリプションであり、アプリケーションのさまざまな機能をアンロックするための方法です。音楽では、Spotifyのようなサービスを考えてみてください。ビデオ、ポッドキャスティングなどです。ですから、クリエイターのためにこの分野のアプリケーションを作ろうとするなら、Unlockのようなものを使ったマネタイズについてぜひ考えてみてください。ここで、本当にパワフルな例として、DeFi Robotの例を挙げたいと思います。DeFi Robotは、取引のヒントや、取引の一部を自動化する仕組みを提供しています。そして、このメンバーシップの面白いところは、明らかにUnlockを使っていることです。メインネットでは、月会費は、私の記憶が正しければ、約300ドルか、ほぼ300ドルで、非常に高価なものです。しかし、メンバーシップを財布に入れると、専用のテレグラム・チャンネルにアクセスできるほか、アプリケーションにあるいくつかの主要な機能にアクセスできるようになります。現時点では、かなりシンプルなアプリケーションであるDeFi Robotは、年換算で約15万ドルの会員収入を得ています。このように、正しく構築すれば、あらゆるコミュニティやソフトウェア・アプリケーションにとって、非常に大きな収益機会となります。先ほどお話したタイムベースのメンバーシップは、必ずしも経常的なものではありませんが、ある種の期間限定的なものです。例えば、DiscordやTelegramにアクセスできるような、季節限定のメンバーシップや、時には永久的なメンバーシップのようなものだと考えてください。そのようなことも可能です。ここで興味深いのは、Unlockのように、会員契約を作成する際に通貨を選択できることです。このような時間ベースのメンバーシップはDAOの分野でよく使われていますが、特定のコミュニティのERC20通貨を価格設定メカニズムとして使用することは、とても素晴らしいことです。その例として、Cabinがあります。Cabinは、2日前に実際に立ち上がったプロジェクトです。これはネットワークCDです。基本的には共同生活の場を持つ人々のコミュニティで、会員制になっており、会員になると、Cabinの会員だけに許された特定のエアドロップや特定の機能を利用できるようになります。ここで興味深いのは、Cabinトークンを1,000枚持っていれば、メンバーシップが無料になるというシステムを構築していることです。このために、このプレゼンテーションの最後のセクションで説明するフックシステムを実際に使用しています。オンチェーン認証は、先ほどもお話しましたが、卒業証書、コースを受けたという事実、ハッカソンに参加したという事実、譲渡はできませんが、知識が最新であることを確認するために、ほとんどの場合、時間制限を設けています。これは基本的に、ファイナンシャル・アドバイザーとして、暗号通貨や暗号資産、デジタル資産に関する教育を受けてきたことを証明するものです。現在までに、100人以上のファイナンシャル・アドバイザーがカリキュラムを修了し、修了証としてNFTの1つを受け取っています。このNFTの面白いところは、例えばLinkedInのプロフィールに追加することで、潜在顧客に自分が認定を受けていることをアピールすることができることです。このように、認証アプリケーションを構築することは、エコシステムの中で人々が行うことに興奮したことのひとつです。ゲームの話も少ししました。これは、Web3のスペースでとても人気のあるゲームです。Pixelsと呼ばれています。ブロックチェーンで構築されたマルチプレイヤーゲームです。ブロックチェーンで構築されたマルチプレイヤーゲームで、アプリ内課金の方法としてアンロックメンバーシップを使用しています。そして、アプリケーションに時間制限のあるさまざまな種類の機能を持たせることができます。このNFTを取得すると、ゲーム内で特定のことができるようになります。ですから、ゲームを作るのであれば、時間制限のあるNFTを利用することも考えてみてください。ロイヤリティのもう一つの例、ユースケースのもう一つの例は、ロイヤリティを中心としたリングです。ここで注目したいのは、Stakesという会社で、基本的にレストランブランドやチェーン店を中心にロイヤルティプログラムを構築しています。そして、ここで興味深いのは、このNFTを1つでも持っていると、レストランの予約ができる予約システムに優先的にアクセスでき、プレミアム顧客として扱われ、レストランにアクセスできるようになることです。

チャンク4の転写：
プレミアムテーブル、フリードリンクやデザートなど、各レストランが顧客に提供する様々な可能性を提供します。最後に、出席NFTですが、エコシステムではアプリ単位と呼ばれることもあります。これは基本的にシステムであり、誰かが何かをしたときに獲得できるNFTであり、それは永遠に有効です。そして、ここで興味深いのは、動的なメタデータ属性を持つことができることです。先ほども簡単に説明しましたが、アンロックは1つから10,000以上のPFPプロジェクトに使用することが可能です。静的または動的なNFTは、ユーザーからの要求に応じて鋳造することも、エアドロップすることも可能で、Unlockがサポートするすべてのネットワークで明らかにサポートされています。Tales of Elettraは、Unlockを使って作られたコレクターズアイテムの一例です。Tales of Elettraが本当に面白いのは、ここにある例のように、それぞれのアバターには、実はアバターといわゆる武器の両方のコンポーネントがあり、どちらもNFTなのです。そして、あるアドレスやユーザーがアバターと武器の両方を所有している場合、武器はアバターの背景に表示されます。例えば、この狼の後ろに矢と弓が表示されているのがお分かりいただけると思います。NFTのユーザーが武器を売却した場合、アバターには弓矢が表示されないことになります。このように、ダイナミックに変化するのです。これは非常に強力なツールだと思います。これから参加される皆さんにお伝えしたいのは、メンバーシップのアンロックプロトコルです。メンバーシップは、多くのビジネスにとって非常にコアなプリミティブで、チケット販売からデジタルコレクション、定期購読、認証資格、ゲーム、ロイヤリティ、出席NFTまで、幅広く利用できます。アンロックはNFTのメンバーシップのフレームワークとして考える必要があり、メンバーシップはさまざまなものになります。というわけで、今まで私の話に耳を傾けていただき、本当にありがとうございました。そして、数分後に正しいセクションに飛び込みましょう。ここでは、Unlockのエコシステムと、アプリケーションの中で使っていただくための開発者向けツールについてお話します。まず最初に、Unlockはプロトコルであることを簡単に覚えておいてください。スマートコントラクトシステムです。もちろん、スマートコントラクトだけを使い、Unlock Labsチームが私たちの上に構築したものには依存しないこともできますし、できることならそうすべきです。しかし、必要であれば、アプリケーションを足場固めするのに良い方法だと思いますので、私たちが構築したツールのいくつかを使って始めることも可能です。たとえば、私たちは2つの重要なフロントエンド・アプリケーションを開発しました。1つ目は、「Unlockダッシュボード」と呼んでいるものです。アンロックダッシュボードは、ロックマネージャーと呼ばれる人たちが、会員契約やロックをデプロイするための手段です。そこから、契約内容を管理することもできます。先ほど見たように、契約は更新可能なので、いくつかの設定、ロックの価格、メンバーシップの数、メンバーシップの期間などを変更することができます。また、メンバーの管理も可能です。つまり、既存のメンバーのリストを見ることができます。メンバーのステータスを変更したり、返金したり、キャンセルしたりすることができます。また、メンバーシップNFTを特定のアドレスにエアドロップすることもできますし、私たちが開発したウォレットレスエアドロップのような機能を使うことも可能です。受信者は請求用リンクが記載された電子メールを受け取り、それを使ってプレースホルダーのアドレスから自分のウォレットにNFTを持ち込むことができます。もちろん、先ほど申し上げたように、この会員契約はERC-721のようなNFT契約なので、このNFTのメタデータをカスタマイズすることも可能です。例えば、イベントを主催したり、イベント・プラットフォームを構築している場合、イベントに特化したメタデータが用意されています。例えば、場所、開始日、開始時間、終了日、終了時間、さらに、例えば、イベントの説明のようなものがあります。同様に、2つ目の重要なアプリケーションとして、チェックアウトと呼ばれるアプリケーションも開発しました。チェックアウトのUIは、ロック・マネージャーのためのものではなく、これからメンバーになる人たちのためのものです。NFTを購入することで、NFTを鋳造することができるのです。購入といっても、エンドユーザーが直接請求でき、ロックマネージャーがドロップするだけでなく、チェックアウトUIを使用すれば、これらのNFTは無料になるケースもあります。チェックアウトUIは、ウォレットの接続から始まり、NFTの鋳造まで、複数のステップからなるフローです。しかし、そのフローの中で、ロック・マネージャーはいくつかのメタデータも収集するように設定することができます。例えば、イベントを開催する場合、参加者の姓名やメールアドレスなどの情報を収集したいと思うかもしれません。このような場合、チェックアウトで簡単に行うことができます。ダッシュボードからアクセスできるノーコードツール、チェックアウトビルダーでこれを設定する方法がありますが、コードで設定することもできます。

チャンク5の転記：
コード、これについては後ほど少しお話します。最後に、先ほど申し上げたように、Unlocked Smart Contractsは、FIATを使った支払いを即座にサポートするように構築されているので、特にクレジットカードを使うことができます。ダッシュボードから設定を行い、ユーザーはチェックアウトのUIから支払い情報を入力することができます。また、スワップや購入といった面白い仕組みもサポートしています。スワップ＆パーチェスとは、基本的にチェックアウトのフローで、ユーザーがメンバーシップの通貨を持っていなくても、ロックが要求する通貨と同じチェーン上の同じネットワークで交換できる別の通貨を持っていれば、それを選ぶことができるものです。例を挙げてみましょう。例えば、PolygonでUSDCを通貨として使っているロックを展開するとします。しかし私自身は、実はUSDCトークンをPolygonにブリッジしたことがないのです。PolygonにはMaticトークンしかありません。それは問題ないです。チェックアウトフローには、ワンクリックでスワップできるオプションが用意されているので、USDCに振り込まれたMaticで支払うと、1回の取引でメンバーシップに交換できます。UIから離れる必要はありません。チェックアウトのUIから直接行えるのです。ダッシュボードとチェックアウトの2つのツールは、基本的にフロントエンドのUIであり、スタートアップに使用したり、アプリケーションに使用したりすることができます。また、開発者がアンロックをアプリケーションに組み込むのに直接役立つ開発者向けツールも多数用意しています。まず、先ほどサブグラフの概念について触れました。ご存知のように、グラフはオンチェーンデータインデックスのためのプロトコルですが、それ以上のものです。私たちはunlockスマートコントラクトのためにカスタムサブグラフを構築しています。このカスタムサブグラフには、明らかにロック、スマートコントラクトの表現が含まれています。サブグラフを使えば、スマートコントラクトからすべての情報を一度に取得できますし、サブグラフから複数のロックを一度に取得することも可能です。あるロックのメンバー全員を1回のトランザクションで取得することができるのです。サブグラフには、最大1,000キー、1,000アイテムという制限がありますが、ページングして1,000、1,000、1,000と増やしていくことができます。サブグラフには領収書と呼ばれるものも含まれます。これは基本的に、スマートコントラクトでどのような支払いが行われたかを識別するために使用できるオブジェクトです。もうひとつ、便利な開発者向けツールとして、unlock.jsというものを導入しました。これは、チェーンからデータを取得するJavaScriptとTypeScriptの実ライブラリです。サブグラフの代わりにこれを使うこともできますが、チェーンの状態を変更するためのトランザクションをトリガーする機能も含まれています。これはEthers.jsをベースにしています。ちなみに、Ethersを特定のロックで使用することもできますが、より多くの手作業が必要なものに対して、多くの構文上の糖分を提供しています。例えば、ロックをデプロイしたい場合はunlock.jsをチェックすべきですし、メンバーシップを購入したい場合は、これは間違いなく可能です。繰り返しますが、EthersやWeb3.jsなど、他の言語の既存のライブラリを利用することも大いに可能です。Unlock.jsは完全にオプションです。もうひとつ、私たちが作ったツールに「Paywall」というものがあります。先ほど、チェックアウトUIについて触れました。チェックアウトUIは、基本的に2つの仕組みを使って表示できるUIです。一方は、チェックアウトURLとして、つまりユーザーのために新しいタブで開くことができる独立したウェブページとして、もう一方は、Paywallの一部として使用することができ、これは、あらゆるウェブアプリケーションの中に埋め込むことができるJavaScriptライブラリです。Paywallは、明らかに彼らとの署名をサポートし、すべてのチェックアウトのステップを含んでいます。これは、例えば、アプリケーションでユーザーを識別したり、別のウェブページに送らずにメンバーシップを購入できるようにしたい場合に、非常に便利です。このPaywallは、JSONオブジェクトを使用して完全に設定可能です。例えば、前のステップで述べたように、収集したメタデータに表示されるタイトル、画像、ロックの数などをカスタマイズすることができます。最後に、私たちが本当に便利だと思うツールを紹介します。実はこの他にもいくつかツールがあるのですが、今回のプレゼンテーションでは、これらだけを明らかにします。フックという概念です。先ほども言ったように、スマートコントラクト自体はプログラミングが可能です。フックを使って、会員制契約の動作を変更することができます。現在、コントラクトには7つのフックがあり、特定のロックに対して呼び出したり実装したりすることで、動作を変えることができます。例えば、on-key purchaseは、誰かがメンバーシップを購入し、それが鋳造されようとするときにトリガーされるフックで、人気のあるフックの一部です。このフックは、ユーザーが特定の条件を満たしているかどうかをチェックするようなことができるので、とても興味深いものです。例えば、特定の許可リストに登録されているか？もしそうなら、次元の購入を完了することができますし、そうでなければ、トランザクションは失敗します。その購入時フックのもう一つの特徴は、トランザクションの種類をカスタマイズする機能が含まれていることです。例えば、トランザクションを行いたい場合、ボタンをクリックすることで、そのトランザクションを行うことができます。

チャンク6のトランスクリプション：
は、ある特徴に基づいてユーザーが支払う価格です。つまり、ユーザーが割引の声の大きい人であるか、購入時に割引コードを入力したかどうかです。実はこの具体例については、このプレゼンテーションの最後のセクションで触れることになります。というわけで、ご興味のある方はそのステップに飛んでみてください。最後にもう一つ、既存の統合について触れておきます。アンロック、パブリックロック、すみません。アンロックプロトコルでは、パブリックロック、メンバーシップ契約は、他のERC721契約と同じです。ERC721の基本仕様が実装されており、転送などの機能も含まれています。ですから、Ethers、Third Web、Web3.js、Wagmeなど、既存のあらゆるフレームワークと連携することができます。また、適切なMetamaskやハードウェアウォレットなど、あらゆる種類のウォレットにも対応しています。また、MagicやPrivyのような、サービスとしての財布のようなアプローチも利用できます。最後に、Unlockは、さまざまなチームによってアプリケーションの中に組み込まれたり、私たちによって他のアプリケーションの中に組み込まれたりしています。例としてMagicを挙げました。これは、Docsのウェブサイトにチュートリアルがあります。Stripeは、Stripe Connectと呼ばれる、暗号で支払いを受け取るための接続を可能にするものです。Superfluidは、ストリーミング・プロトコルです。Uniswap、これは先ほどスワップや購入のフローとして説明したものに対応するものです。E-Fastは、ユーザーがiOSやAndroidのパスを携帯電話にダウンロードし、NFTやその他を表現することができるものです。既存のプラットフォームへのインテグレーションを構築している方は、ぜひチームにご連絡ください。ご連絡をお待ちしています。私たちは、あなたがこれを構築するのをぜひお手伝いしたいと思います。Unlock Protocolのエコシステムの概要をもう1つお見せしましょう。基本的に、これらはすべてUnlockをネイティブに動作させるか、統合したアプリケーションです。つまり、さまざまなプロトコルがあるわけです。例えば、Lit Protocolは暗号化を行うトークンゲートプロトコルです。Unlockのメンバーシップを使って、特定のコンテンツを暗号化するかしないかを決定することができます。先ほどのSuperfluidと連携しています。Livepeerとも連携しています。実は、私たちはLivepeerとの統合を望んでいます。Livepeerはビデオプロトコル、ストリーミングビデオプロトコルで、ライブストリームのトークンゲートに使うことができるのです。また、多くのアプリケーションでUnlockが使われています。Guildはその良い例です。Coinviseは、クリエイターが会員制サービスを展開・管理し、会員制サービスをコミュニティと連携させるために使用できるUIです。動画にはBeam、NotionにはMonetizeといったものを使って統合することもできますし、その他にもいろいろあります。また、Unlockを直接アプリケーションに組み込んで使っている代理店や友人もたくさんいます。また、Unlockを直接自社のアプリケーションに組み込んでいる代理店や友人もたくさんいます。最後に、Unlockの上に構築されたプロジェクトがたくさんあります。このリストを使ってみてください。注意点として、私たちは実際には9つのネットワークで利用可能です。EtherMainnet、Polygon、GnosisChain、Optimism、Arbitrum、Celo、Binance、Palmがここにない1つです。もう一度、私たちのドキュメントを確認してください。これにはすべてのリンクがあります。ちなみに、これらのネットワークには、対応するサブグラフや、クレジットカードやシステムなど、他のスマートコントラクトも当然導入されています。この後、次のセクションに進みましょう。今日最初のチュートリアル、Unlockを使ったトークン・ゲート・アプリケーションの作り方に飛び込んでみましょう。つまり、スマートコントラクトのコードを書くつもりはありません。Solidityのコードを書くつもりもありません。JavaScriptの技術を使ってフロントエンドのアプリケーションを構築することだけに焦点を当てます。まず、私が作った基本的なアプリを見てみましょう。これは通常のNext.jsアプリケーションです。私はここから始めます。このセクションは基本的に会員制のセクションで、ユーザーが最初に認証した場合にのみ表示されます。ウォレットにメンバーシップがない場合は、購入するように促します。そして、ユーザーが誰なのかがわかるまでは、ユーザーを認証する仕組みを追加します。それでは、実際にアプリケーションを簡単にお見せしましょう。これが基本的なアプリのコンポーネントです。これもNext.jsアプリケーションの一種です。1つのコンテンツセクションに1つのページがあり、トークン・ゲートにしたいコンテンツが少し含まれています。まず、いくつかの依存関係をインストールすることから始めましょう。そして、2つの依存関係をインストールしたいと思います。具体的には、ここにあります。そう、ここにあります。WagmiはJavaScriptで、実際にはReactフロントエンドで、スマートコントラクトとウォレットの接続を扱うためのReactフックフレームワークです。Ethersは低レベルのJavaScriptライブラリで、ウォレット内の同じスマートコントラクトと対話するものです。この2つをインストールします。かなり基本的なものです。

Chunk 7 transcription: 
そして、私たちのアプリを見に行きましょう。ここで、最初にやりたいことは、当然ながら、先ほどインストールした依存関係を追加することです。だから、ファイルの一番上にそれを書くだけで、あまり派手なことはしないことにします。それから、WADMEクライアントと呼ばれるものを作成します。このクライアントが、ウォレットとやりとりするために使うものです。これは基本的に、すでに接続しているユーザーがページを読み込んだときに、接続を維持し、自動接続することを許可するものです。さらに、プロバイダを渡しています。プロバイダーはネットワーク・コンポーネントで、構築するアプリケーションがブロックチェーンに接続できるようにするものです。そして、開発用にUnlockが提供するRPCエンドポイントを使っています。この行をAlchemyやInfiorなどのRPCプロバイダに置き換えていただいても結構です。ここには小さなネットワーク・コンポーネントがあります。そして明らかに、設定ファイルから小さなNを削除する必要があります。設定ファイルを見てみましょう。今のところ、ネットワークだけで、大したものは入っていません。これを手に入れたら、当然、次の... おっとっと。これは私がやりたいことだと思います。これができたら、このコンポーネントをWAGMIプロバイダと呼ばれるもので包む必要があります。これは、特定のコンテキスト用のReactプロバイダで、アプリケーション上で接続できるようにするものです。これが基本的なセットアップです。再確認してみますが、アプリケーションはまだアクセス可能です。コードの観点からは何もしていないため、何も変わっていません。次に、インデックス・ページを見てみましょう。このページでやりたいことは、明らかにユーザが接続されていることを確認することから始めます。このために、WAGMIライブラリの他のコンポーネントを使用します。そこで、これらの依存関係をすぐにトップに追加することにします。まず、接続されているユーザーに関する情報を取得するuseAccountと、ユーザーを接続するuseConnectを使用します。また、このインジェクション・コネクタを使用していますが、これは基本的にWebブラウザでインジェクション・ウォレットを取得する方法です。そこで、この2つのフックをここに追加することにします。そして、アプリケーションの動作を少し変えて、ユーザーが接続していない場合は、基本的にユーザーに接続させるボタンを追加することにします。ユーザーが接続している場合は、コンテンツを表示します。そして明らかに、ここに小さな括弧がありません。しかし、コンテンツだけでなく、切断するためのボタンも追加することにします。同じ要素に2つのコンポーネントを入れるので、このようにします。切断には、WAGMIの別の機能である切断関数を使用します。ということで、今回はここまでとします。ページを更新してみましょう。以前接続したので、すでに接続されています。そこで、ここから接続を解除します。そうすると、ここで接続が切れるのがわかります。そして、ここから接続を切ります。アプリケーションを更新すると、この接続ボタンだけが表示されます。接続をクリックします。私のウォレットはプロンプトを表示するはずですが、やはり先ほどは接続されていません。接続を促しているわけではありませんが、接続されました。そして、コンテンツを見ることができます。このように、かなり簡単です。さて、興味深いのは、接続されたユーザーがいることです。ユーザーの財布の中身はわかっています。次のステップでは、特別なコンポーネントを追加することになりますが、これは基本的にTokenGateと呼ぶことにします。では、実際にやってみましょう。新しいコンポーネント、TokenGate.tsxを追加することにします。このコンポーネントは非常にシンプルなものになります。今のところ、子プロセスを返すだけです。つまり、今のところ何もトークン化していないのです。ただ、持っているコンテンツを提供するだけです。そして、これから行うのは、実際にコンテンツをTokenGateコンポーネントの中に包むことです。このように、ファイルの一番上にこれを含めることを確認したいのです。コンテンツ・コンポーネントはまだここにありますが、今回はそれをTokenGateコンポーネントにラップしています。このコンポーネントには、ユーザが接続されてアクセスできることを確認するロジックがあります。今のところ、またしても何も変わっていません。しかし、ここをクリックすると、コンテンツを表示することができます。しかし今回は、このTokenGateコンポーネントを使用して、この問題を解決する方法があります。このコンポーネントはもう少し複雑なものになりそうです。そういえば、子供用のプロップを追加するのを忘れていました。このコンポーネント自体が少し複雑になりそうなので、さっそくこのコンポーネントを使って作業してみましょう。では早速、このコンポーネントを使ってみましょう。

チャンク8のトランスクリプションです： 
ここでもWagmeのライブラリを使用します。useAccountはウォレットアドレスを取得するために使いますが、useContractWidも使って、スマートコントラクトに関する情報を取得するためのフックにします。ここで、これまで使っていなかった別のライブラリも入れておきます。実際にインストールしてみますが、これはUnlockが提供するコンポーネントで、APIが含まれています。APIとは、スマートコントラクトが持つAPI記述のことで、必要であれば、このAPIを利用します。ここで追加と言うのを忘れていました。削除しなければならない引用がありますが、この依存関係を今追加します。インストールには2、3秒かかるでしょう。これの何がいいかというと、これをコードに使うことができるようになることです。実際にやってみましょう。実際に追加するのは、今のところここまでです。最初のステップは、ここに貼り付けているロジックを追加することです。ロック・アドレス、これはもう一つの構成で、アドレスはユーザーの住所になります。実は、このアドレスはuseAccountコンポーネントから直接取得することができます。const address equals useAccountとし、lock addressには設定にあるアドレスが含まれるようにします。これからコンフィグに書いていきます。ロックは、先ほど説明したように、会員契約なので、ここにアドレスを追加します。以前デプロイした会員契約以外は、ここでその作業をする必要はありませんが、ロック解除のダッシュボードから簡単にできることを知っておいてください。実際にTokenGearコンポーネントに戻ってみましょう。この興味深いフックが呼び出され、いくつかのデータを取得しようとしています。そのデータについては、後で見てみましょう。エラーがあればこの変数にtrueがセットされ、読み込み中であればこの変数にtrueがセットされます。引数として渡しているのは、まずロックアドレス、取得するスマートコントラクトアドレス、パブリックロックのバージョン13のABIです。ここで使っている関数はbalance offというもので、プロトコルの最新バージョンです。これは、引数として渡している指定されたアドレスに有効なメンバーシップ・トークンがあるかどうかを契約から取得する方法です。ユーザーが有効なメンバーシップトークンを持っていない場合や、有効期限が切れている場合は0を返し、ユーザーが持っている有効なメンバーシップの数に応じて、1、2、3、4、5を返します。ここで、ちょっとだけロジックを追加してみましょう。もちろん、ページがロード中の場合は、すぐに子供たちを表示させることはしません。また、何らかのエラーが発生した場合も、コンテンツは表示しません。最後のステップは、データがゼロに等しい場合、このコンテンツにアクセスするにはトークンが必要ですというようなことを表示します。これを保存して、実際にページにアクセスしてみましょう。すでに自己更新されていますが、コンテンツにアクセスするにはトークンが必要だと表示されているのがわかります。この時点では、会員制ではないので、中身を見ることはできません。本当に何もない、これは予想通りです。次のステップは、ここに別の関数を追加することでしょう。ユーザーに「アクセス権がありません」と伝えるのではなく、「アクセス権がない場合は、メンバーシップを購入する必要があります」と表示するのです。このボタンを「メンバーシップを購入する」というボタンに置き換え、新しいチェックアウト関数をこのコンポーネントに追加します。この関数は、空のバージョンで開始します。ここでは何もせず、この関数の実装を検討します。この実装には、Unlockチームが提供しているもう1つのライブラリ、Paywallライブラリを使います。Paywallライブラリは基本的に、その名の通り、ユーザーがチェックアウトしたりメンバーシップを購入したりできるウェブページに追加できる、簡単なペイウォールです。また、UnlockのNetworksパッケージと呼ばれる、Unlockのすべての設定が入った便利なパッケージも追加します。これも完全にオプションですが、これを使うと非常にシンプルになります。では、このコードに戻り、チェックアウトに何を入れるか見てみましょう。

チャンク9の転記です： 
まず、面白いことをしますよ、いくつか面白いことがあります。コネクタが使用するプロバイダをロードするつもりです。コネクタは、実はユーザーアカウントから取得するもので、ユーザーのウォレットに接続するオブジェクトです。このプロバイダーを取得し、ペイウォール・オブジェクトをインスタンス化します。これもunlockライブラリから取得したものです。これを追加するだけです。ここでは、要件として一番上に追加していません。そして、paywall configとnetworksですが、実はnetworksは、先ほどインストールしたパッケージから持ってきています。ですから、これも追加しておきます。そしてペイウォール設定は、コンフィギュレーションから取得します。これもすぐに確認しましょう。この行をこの行に置き換えるだけです。そして、ペイウォール設定は、以前作ったものをコピーペーストしておきます。これは基本的にJSONブロブで、これを構築する方法の詳細は、unlockのドキュメントに記載されています。これでペイウォールの動作を設定することができます。ここでは複数のロックが必要ですが、この例では1つだけにしています。複数のロックを持つこともできますが、ここでは1つだけ、ネットワーク番号5のロックアドレスを持ちます。ユーザーが自分で購入することを想定して、受取人のステップを省略します。そして、名前を入れます。コンバイン・メンバーシップ、あるいはマイ・アプリ・メンバーシップの方が正確かもしれませんね。これは基本的に、ユーザーがアプリケーションに戻る前にトランザクションが採掘されるのを待つことを要求するものです。次にTokenGateコンポーネントに戻りましょう。ペイウォールがありますが、これだけでは十分ではありません。追加する必要があるのは、ユーザーがチェックアウトをロードする機能です。ここにこれを追加します。基本的に、チェックアウトモデルの読み込みは非同期関数で、小さなチェックアウトモデルを表示するようになっています。さっそく見てみましょう。では、実際にアプリケーションにアクセスしてみましょう。ここにはボタンがあり、とても便利です。コンソールログも残っているので、ちょっとごちゃごちゃしていますが、大丈夫です。ここをクリックすると、どうなるのでしょうか？チェックアウトモデルが読み込まれます。アプリのメンバーシップとスマートコントラクトは、先ほど指定したアドレスにあります。これが正しいアドレスであることを確認できます。これはすべて素晴らしいことです。しかし、実際に残りを見てみましょう。閉じても何も起こりません。これは期待通りです。結果がある場合、その結果オブジェクトの中にハッシュが入るのが面白いところです。ここで興味深いのは、このハッシュをUIで使いたいことです。ハッシュが何であるかは、後で説明します。そこで、Reactのuse stateを使うことにします。ここで、私たちがやりたいことは、基本的に、待つことが重要であること、寄付を待っていることをユーザーに示す、より良いUIを持つことです。ですから、たとえメンバーシップを持っていなくても、もし彼らが購入したばかりなら、これを削除して、トランザクションが確認されるまで数秒待つことにします。そして、これが確認されると、子供たちに会えるようになることを期待します。では、このアプリケーションの最終テストを行う準備ができました。ここで「接続」をクリックします。この時点で、私の財布は接続されています。そして、「メンバーシップを購入する」ボタンをクリックします。この小さなポップアップが表示されます。そして、「次へ」をクリックします。そして、これは更新であり、私はすでに以前にメンバーシップを購入しているはずです。そこで、このトランザクションを送信する必要があります。ブロックエクスプローラーで確認することができます。ブロックチェーントランザクションが鋳造されていることがわかります。ここで1～2秒待つ必要があります。ああ、これは私のものだ。通常、Unlockの内部でもう2ブロックほど待ちます。それで、うまくいけば、これを閉じることができます。これでコンテンツにアクセスできるようになったのがわかります。ページを更新して、「接続」をクリックします。コンテンツが表示されているのがわかると思います。メンバーシップの有効期限が切れたら、実はもうじき切れるはずなんです。いいえ、まもなくです。再接続して再度購入する必要があります。というわけで、今日はここまでです。ここでビデオを止めます。スマートコントラクトでUnlockを使う方法 ここでは少し特別なことをします。つまり、会員契約であるパブリックロックの動作を変更するフックを実装するのです。ここでやりたいことは、実はとてもシンプルなことです。新しいメンバーシップが販売されるたびに、次のメンバーシップの価格が少し上がるようにしたいのです。これは通常、ボンディングカーブと呼ばれるものです。これは、いわゆる価格発見メカニズムを実装するのに適した方法で、基本的に新しいメンバーシップが販売されるたびに、価格が上昇します。そして、ある時点で、価格が高すぎるため、もう会員権は売らないと考えるでしょう。では、さっそく始めてみましょう。そのために、新しい契約を作ることにしましょう。

チャンク10の転記：
ここで新しいフォルダーを作るのです。おっとっと。さて、私はすでに、まあ、それは実際にここで例をやっている、そして我々はちょうどその1にCDをします。ボンディングカーブはすでにローカルにあるんです。それから、npx rhatというコマンドを実行して、ハードハット・ツール・セットをインストールします。Hard hatはEthereumの世界で人気のあるツールセットの1つです。使用するプロジェクトには、ぜひとも使用を検討すべきです。UnlockedInとは関係ないので、ここではデフォルトのオプションを完成させるだけです。そして、はいと答えて、ここにツールボックスをインストールし、数秒待ってみましょう。ハードハットがこの作業を行うと、多くの依存関係がインストールされるだけでなく、プロジェクトの足場が作られます。それでは、完了するまで数秒待ってみましょう。その間に、コードを開いて中身をお見せしましょう。実は、12docのような契約書があるんです。非常にわかりにくいのですが、これはUnlockedとはまったく関係ありません。このファイルにはテストもあり、基本的にこれから書く契約の動作をテストするものです。また、興味深いことに、ハードハット用の設定ファイルもありますから、これから実際に見ていきましょう。依存関係がインストールされましたね。あと2つ、依存関係をインストールしましょう。1つはunlock contractパッケージです。アンロックプロトコルパッケージを追加します。そして、ハードハット専用のアンロック・プラグインがあります。この後すぐにインストールして、すべてが期待通りに動くことを確認します。これができたら、必要な設定がすべて含まれていることを確認するために、ファイルを修正する必要があります。基本的には、ロック解除プラグインが使用されることを確認するために、ここでロック解除プラグインを追加するという簡単なことを行う必要があります。これでほぼ完了です。では、実際にyarn run testをやってみて、すべてが期待通りに動いていることを確認しましょう。ヤーンランハードハットテスト、すみません。そして、依存関係がたくさん足りないので、インストールしましょう。これは実はyarn as thisで、yarn addです。それでうまくいくはずです。どこかに引用がありますね。Yarn addはここです。このように、ハードハットが特に使用する余分な依存関係をすべてインストールしています。完了するまで少し待ってみましょう。しかし、インストールが完了したら、まずはコードをきれいにすることから始めましょう。実際に使うのは、あるいは名前を変えて、ボンディング・カーブ、ボンディング・カーブ、あ、入力できない、ボンディング・カーブ・フック.ソルとでもしましょうか。つまり、契約書もボンディング・カーブ・フックに改名することになります。そして、その中にあるものをほとんどすべて削除します。コンストラクターは、たぶん何も入っていないはずです。payableにするのはやめましょう。payableにしたところで、実際には何の役にも立たないからです。これがフックの最も基本的なバージョンです。テストも見てみましょう。その結合の名前を変更します。これでいいと思います。そして、テストを修正します。というわけで、早速ですが。新しいキー、新しいメンバーシップが購入されたときのロックの動作を変更します。そのためには、スマートコントラクトに2つの関数を実装する必要があります。1つは鍵の購入時に呼び出される関数で、これは鍵の購入価格と呼ばれています。この関数が何をするものかは、後で説明します。そして2つ目の関数は、少し、つまりかなり基本的なものですが、オンキー購入関数を実装する必要があります。最初の機能は、ロック、メンバーシップ・コントラクトが、購入機能の送信者であれ、受信者のアドレス、参照者であれ、その機能を呼び出すというものです。これらはロック解除に特有の概念なので、ドキュメントで確認してください。また、データ引数もあります。そして、この関数はキープライスを返すことが期待されています。

チャンク11の転記：
ここでは、デフォルトのキープライスを返すことにします。つまり、基本的には、通常のキープライスを返すようにします。そして、この関数を作成するためのインターフェース・ファイルを含めるのを忘れていたことに気づきました。2つ目の関数は、購入が成功したときに購入関数の末尾で呼び出されるものです。この関数は、契約の状態を変更するために使用されます。そのためには、基本的にとても簡単なことをするだけです。つまり、このコントラクトを呼び出すトランザクションの送信者として取得したロックがある場所を作るのです。そして、価格を取得します。ここで2倍します。価格は毎回2倍になります。そして、価格を変更するためにupdate key pricing関数を呼び出します。つまり、この関数を呼び出して価格を変更するわけですが、当然、通貨は同じままです。トークンのアドレスはロックの通貨であり、FC20やチェーンの基本通貨である可能性があります。つまり、この時点で契約はかなり実装されているのです。他にやることはあまりありません。次のステップは、当然ながらテストを修正することです。ここで、warrayの内容を説明します。それぞれの値に対して配列を渡しますが、ここではわかりやすくするために、それぞれの値に対して空の配列を渡します。このトランザクションが実行されたら、キープライスが以前の2倍に変更されたことを確認します。つまり、キープライスは1グイでしたが、今は2グイになっているはずです。次のステップはテストを実行することで、すぐにコンパイルされます。これでこの演習は終了です。このコードでは、まずロックを作成し、新しいメンバーシップが購入されるたびにメンバーシップの価格を変更するフックを追加しています。もっと詳しく知りたい方は、当社のドキュメントをご覧ください。docs.unlock-protocol.comには、フックの作成方法に関する具体的なチュートリアルが用意されています。ありがとうございました！またお会いしましょう。